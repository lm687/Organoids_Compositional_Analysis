---
title: "Analysis of HGSOC organoids and comparison to clinical cohorts"
author: "Lena Morrill"
date: "2020"
output:
  html_document:
  number_sections: true
theme: cosmo
toc: true
toc_float: true
---
  This code seeks to explain how do organoids from patients reflect the generality of OV patients. We do clustering of patients and organoids and see where organoids fall -- based on signatures, and also based on raw CN profiles.


**To do**: Create the new britroc OV exposures using the new code that Ruben has provided and the new absolute copy number segments that he has provided too.

# Considerations
- From conversation with Geoff 20200129, we will be getting different absolute copy number files (and their corresponding exposures) because the method of purity/ploidy inference has been improved.
- OV-US and OV-AU are both ICGC
- version of the TCGA etc signatures: the new exposures (sent by Ruben on late November) I just have for TCGA, but this is because the ASCAT segments have been modified differently, and it shouldn't make a difference for non-SNP array.
- version of the organoid signatures: I am using version "organoid_exposures_Aug21.rds"


Changes in signatures extraction (from Ruben)
- removing a big from one the features: the first segment was not counted, whih  is not too important for OV
- the pre-processing of CN segments (only applicable to SNP array)

The previous data are:

- 132 patients (BriTROC-1) using low-cost shallow whole-genome sequencing (sWGS; 0.1×)
- 112 dWGS HGSOC cases from the Pan-Cancer Analysis of Whole Genomes (PCAWG)
- 415 HGSOC cases with SNP array and whole-exome sequencing data from The Cancer Genome Atlas (TCGA)


BriTROC: there are the original BriTROC segments (from manuscript) and new BriTROC segments (called BriTROC 2, here, but it's not the BriTROC-2 cohort! made by Ruben).

<!-- **To do**: for (1) signatures, and (2) CN profiles, do (1) clustering, (2) PCA (i.e. 4 plots). -->
  
  
```{r, knitr_opts, echo=FALSE}
knitr::opts_chunk$set(cache = TRUE)
```

```{r, libraries, message=FALSE, cache=FALSE, echo=FALSE}
library(grid)
library(gridExtra)
library(dendextend)
library(ggrepel)
library(cowplot)
library(compositions)
library(CompSign)
library(QDNAseq)
library(Biobase)
library(RColorBrewer)
library(dplyr)
library(tidyverse)
library(MASS)
library(pheatmap)
library(ggdendro)
library(readxl)
library(CNTools)
library(GenomicRanges)
require(ggthemr)
# source("../../../../other_repos/BriTROC-cnsignatures-bfb69cd72c50/main_functions.R")
source("../../cnsignatures/main_functions.R")
# source("../../cnsignatures/helper_functions.R")
source("helper_functions.R")
```

```{r, cols,include=FALSE, eval=TRUE}
n <- 60
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unique(unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))))
chrlen = readRDS("data/chrlen.RDS")
```

```{r, short_functions, echo=FALSE}
give_short_names = function(i){
  if(grepl('TCGA', i)){
    paste0(strsplit(i, split = '-')[[1]][1:3], collapse='-')
  }else{
    i
  }
}

clr_vec <- function(x){
  log(x) - mean(log(x))
}

clr_mat <- function(X){
  .res <- t(apply(X, 1, clr_vec))
  stopifnot(dim(.res) == dim(X))
  .res
}
```


# Loading organoids data
```{r, load_organoids}
org<- as(readRDS("data/organoid_exposures.rds"), 'matrix')
# rownames(org) <- paste0('Sample ', 1:nrow(org))
# names_orgs = readxl::read_xlsx("data/NewOrganoidNaming.xlsx")
names_orgs = read_csv("data/NewOrganoidNaming.csv")
names_orgs$`new name`[match(rownames(org), paste0(names_orgs$`old name`, 'org'))]
rownames(org) = names_orgs$`new name`[match(rownames(org), paste0(names_orgs$`old name`, 'org'))]
```

## Data from organoids

```{r, funs}
rename_rows = function(i, new_names){
  rownames(i) = new_names; return(i)}
```

```{r, barplot_organoids, fig.height=2.5,message=FALSE, echo=FALSE,warning=FALSE}
createBarplot(rename_rows(org, gsub('Sample ', 'PDO', rownames(org))), remove_labels = FALSE, order_labels = gsub('Sample ', 'PDO', names(sort(org[,1])))) + 
    scale_fill_brewer(palette="Dark2")+labs(y='Exposure')+
  ggtitle('Exposures for the organoids')+labs(x='')+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggsave("figures/exposures_organoids.pdf")
saveRDS(rename_rows(org, gsub('Sample ', 'PDO', rownames(org))), "robjects/exposures.RDS")
```

Apparently only PDO1 is a WGD sample. I see which log-ratio with any other signature shows a clear difference between this WGD sample and the rest. The ratio between s4 (WGD signature) and s2 is.
```{r, WGD, echo=FALSE, fig.width=12}
melt_exposures_WGD = (melt(sapply(1:ncol(org), function(j) org[,'s4']/org[,j])))
melt_exposures_WGD$group = ifelse(melt_exposures_WGD$Var1 == 'PDO1', 'WGD', 'No WGD')
melt_exposures_WGD %>% filter(Var1 == 'PDO1')
grid.arrange(ggplot(melt_exposures_WGD, aes(x=Var2, y=value, col=Var1))+geom_point()+facet_wrap(.~group),
             ggplot(melt_exposures_WGD %>% filter(Var2 == 2), aes(x=Var1, y=value))+geom_point()+facet_wrap(.~group)+
               theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)), ncol=2)
```

```{r, zeros_organoids}
apply(org, 2, function(j) table(factor(j==0, levels=c(T,F))))
table(apply(org[,-5], 1, function(j) paste0(j==0,collapse='-')))

```

```{r, barplot_old_exposures, fig.height=2.5, echo=FALSE}
# naming_table=readxl::read_xlsx("~/Desktop/PDOnameProperSample_sWGS.xlsx")
# org_old<- as(readRDS("data/organoid_exposures.rds"), 'matrix')
# naming_table$PDO[match(naming_table$ID, rownames(org_old))]
# createBarplot(org_old, remove_labels = FALSE, order_labels = names(sort(org_old[,1]))) +
#     scale_fill_brewer(palette="Dark2")+labs(y='Exposure')+
#     theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
#   ggtitle('OLD Exposures for the organoids')
# 
# tail(naming_table[match(gsub('Sample ', 'PDO', rownames(org)), naming_table$PDO),])
# org_old[naming_table$ID[match(gsub('Sample ', 'PDO', rownames(org)), naming_table$PDO)],]
# org
# 
# matched_vector_old_exp = as.vector(org_old[naming_table$ID[match(gsub('Sample ', 'PDO', rownames(org)), naming_table$PDO)],])
# ggplot(cbind.data.frame(new=as.vector(org), old=matched_vector_old_exp, label= ifelse(matched_vector_old_exp>0.4, gsub('Sample ', 'PDO', rownames(org)), NA), sig=factor(rep(1:7, each=nrow(org)))), aes(x=old, y=new, col=sig, label=label))+geom_abline(slope = 1, intercept = 0)+geom_point()+geom_label_repel()
```


### Data from Nature Genetics 2018 paper

We are loading both the original signatures, and the updated signatures.
```{r, natgen_data,include=FALSE}
#------------ Load ------------#
natgen = natgen_metadata = list()
sig_data = readRDS("data/sig_data_unorm.RDS")
sig_data = cbind(sweep(sig_data[,1:7], 1, rowSums(sig_data[,1:7]), '/'),
                 sig_data[,8:ncol(sig_data)])
natgen[[1]] <- as.matrix(sig_data[,1:7])
createBarplot(natgen[[1]])
natgen_metadata[[1]] <- sig_data[,8:10]
natgen[[2]] <- readRDS("data/Export-matrix_OV_Sigs_on_TCGA-OV_12112019.rds")
natgen_metadata[[2]] <- cbind.data.frame(study=rep('Updated TCGA', nrow(natgen[[2]])), age=NA, age.cat=NA, stringsAsFactors = FALSE, row.names=rownames(natgen[[2]]))
names(natgen_metadata) = names(natgen) = c('ExposuresNatGen', 'UpdatedExposures')

#------------ Only keep TCGA samples which are of good enough quality------------#
summary_ascat = read.table("data/summary.ascatTCGA.penalty70.txt", header = TRUE, stringsAsFactors = FALSE)
good_tcga = summary_ascat$name[summary_ascat$dCIN]
good_tcga = good_tcga[!is.na(good_tcga)]
bool_tcga= lapply(natgen, function(i) grepl('TCGA', rownames(i)))
rm_na = function(df) !apply(df, 1, function(rw) all(is.na(rw)))

## modify the dataframes
for(version in 1:2){
  rm_bad_samples = !(sapply(rownames(natgen[[version]])[bool_tcga[[version]]], give_short_names) %in% good_tcga)
  natgen[[version]][bool_tcga[[version]],][ rm_bad_samples,] <- NA
  natgen[[version]] = natgen[[version]][rm_na(natgen[[version]]),]
  natgen_metadata[[version]][bool_tcga[[version]],][ rm_bad_samples,] <- NA
  natgen_metadata[[version]] = natgen_metadata[[version]][rm_na(natgen_metadata[[version]]),]
}
rownames(natgen[[1]]) = as.character(sapply(rownames(natgen[[1]]), give_short_names))


#------------ add the non-TCGA samples to natgen2 ------------#
bool_tcga = lapply(natgen, function(i) grepl('TCGA', rownames(i))) ## re-compute
bool_tcga_metadata = lapply(natgen_metadata, function(i) grepl('TCGA', rownames(i))) ## re-compute
natgen[[2]] = rbind(natgen[[2]], natgen[[1]][!bool_tcga[[1]],])
natgen_metadata[[2]] = rbind(natgen_metadata[[2]], natgen_metadata[[1]][!bool_tcga[[1]],])
stopifnot(dim(natgen[[2]])[1] == dim(natgen_metadata[[2]])[1])
bool_tcga = lapply(natgen, function(i) grepl('TCGA', rownames(i))) ## re-compute
```

### Number of zeros in exposures
We have two dataframes: with the previous TCGA samples and with the current ones. Both contain the BriTROC and ICGC to this as well (which are shared).

```{r, zeros, echo=FALSE}
cat('The percentage of zeros in each cohort is:\n')
zeros_percentage = lapply(list(organoids=list(org),
                            ExposuresNatGen=split(x = natgen[[1]], f = factor(natgen_metadata[[1]]$study)),
                            UpdatedExposures=split(x = natgen[[2]], f = factor(natgen_metadata[[2]]$study))),
                          function(j) lapply(j, function(i) paste0(signif(sum(i==0)/length(i)*100, 5), '%')))
names(zeros_percentage) = c('organoids', 'ExposuresNatGen', 'UpdatedExposures')
print(zeros_percentage)
```

This makes the organoids and the TCGA exposures sample, and leaves the other in the periphery of the PCA. I suspect this is due to the number of **zero exposures**, which are imputated using the robust analyses that I am using here:

```{r, comparison_tcga_exposures, echo=FALSE, cache=FALSE}
# Only selecting those which are TCGA
num_of_current_not_in_previous = sum(is.na(match(rownames(natgen[[2]])[bool_tcga[[2]]],
                                                 natgen[[1]])[bool_tcga[[1]]]))
num_of_previous_not_in_current = sum(is.na(match(rownames(natgen[[1]])[bool_tcga[[1]]],
                                                 rownames(natgen[[2]])[bool_tcga[[2]]])))

num_exposures_tcga_previous = length(rownames(natgen[[1]])[bool_tcga[[1]]]) ## Natgen exposures
num_exposures_tcga_current = length(rownames(natgen[[2]])[bool_tcga[[2]]]) ## new, from Ruben

```

- The number of organoids is `r dim(org)[1]`
- The number of TCGA samples in the previous (published) cohort was `r {num_exposures_tcga_previous}`.
- The number of TCGA samples in the current (Ruben's) cohort is `r {num_exposures_tcga_current}`.
- The number of TCGA samples found in the previous cohort but not in the current is `r {num_of_previous_not_in_current}`.
- The number of TCGA samples found in the current cohort but not in the previous is `r {num_of_current_not_in_previous}`.


We are only selecting the updated exposures, now
```{r, which_signatures, eval=TRUE}
which_natgens = c('UpdatedExposures')
which_natgen = 'UpdatedExposures'
```

# PCA
For compositional data, in the book Analysing compositional data with R they say that PCA should be done on clr-transformed data. Zeroes are an issue if we use clr using all samples. The robust clr is implemented in the package compositions and deals with this problem by doing the geometric mean over only non-zero values, and setting the clr of a part which is zero to zero.

The plot done with (biplot(princomp(acomp(x)))) is the same as plotting princomp(as(clr(x), 'matrix'))

```{r, clr,include=FALSE,eval=TRUE}
org_clr <- clr_mat(org)
org_clr_robustzeroes <- as(compositions::clr(org), 'matrix')
rownames(org_clr_robustzeroes) <- rownames(org_clr) <- paste0('Organoid ', rownames(org_clr))
```


## Creating a PCA with the data from the clinical cohorts, and projecting the organoids

```{r, princomp, echo=FALSE, eval=TRUE, fig.height=6, fig.width=10}

pca_from_projection = prcomp_all = df_prcomp_exposures = list()
for(which_natgen in which_natgens){
  prcomp_all[[which_natgen]] <- princomp(as(clr(natgen[[which_natgen]]), 'matrix'))
  
  df_prcomp_exposures[[which_natgen]] <- data.frame(prcomp_all[[which_natgen]]$scores[,1:2], study=natgen_metadata[[which_natgen]]$study, labels=NA)
  df_prcomp_exposures_org <- data.frame(predict(prcomp_all[[which_natgen]], (org_clr_robustzeroes))[,1:2], 'Organoid', rownames(org))
  colnames(df_prcomp_exposures_org) <- c('Comp.1', 'Comp.2', 'study', 'labels')
  df_prcomp_exposures[[which_natgen]] <- rbind(df_prcomp_exposures[[which_natgen]], df_prcomp_exposures_org)
  df_prcomp_exposures[[which_natgen]]$labels <- gsub('Sample ', '', df_prcomp_exposures[[which_natgen]]$labels) ##here
  
  myColors <- col_vector[1:length(unique(df_prcomp_exposures[[which_natgen]]$study))]
  names(myColors) <- unique(df_prcomp_exposures[[which_natgen]]$study)
  #ggthemr('flat dark')
  #ggthemr_reset()
  # set_swatch(myColors)
  
  var_explained1 <- (prcomp_all[[which_natgen]]$sdev**2)/sum(prcomp_all[[which_natgen]]$sdev**2)
  
  pca_from_projection[[which_natgen]] = ( ggplot(df_prcomp_exposures[[which_natgen]], aes(x=Comp.1, y=Comp.2, col=study))+
    geom_point() +
    geom_label_repel(data = df_prcomp_exposures[[which_natgen]][!is.na(df_prcomp_exposures[[which_natgen]]$labels),], aes(label=labels))+
    ggtitle(paste0("PCA of both datasets with projection,\n dataset: ", which_natgen))+
    labs(x=paste0('PC1 (', round(var_explained1[1], 2)*100, '%)'),
         y=paste0('PC2 (', round(var_explained1[2], 2)*100, '%)'))+
    theme_bw())
}
names(df_prcomp_exposures) = which_natgens

pca_from_projection[['UpdatedExposures_onlyTCGA']]= ggplot(df_prcomp_exposures[[which_natgen]][grepl('TCGA|Organoid',
                                                                                     rownames(df_prcomp_exposures[[which_natgen]])),],
                                                           aes(x=Comp.1, y=Comp.2, col=study))+
    geom_point() +
    geom_label_repel(data = df_prcomp_exposures[[which_natgen]][grepl('TCGA|Organoid', rownames(df_prcomp_exposures[[which_natgen]])) & !is.na(df_prcomp_exposures[[which_natgen]]$labels),], aes(label=labels))+
    ggtitle(paste0("PCA of both datasets with projection,\n dataset: only TCGA", which_natgen))+
    labs(x=paste0('PC1 (', round(var_explained1[1], 2)*100, '%)'),
         y=paste0('PC2 (', round(var_explained1[2], 2)*100, '%)'))+
    theme_bw()


pca_all_clinical <- pca_from_projection[['UpdatedExposures']]+theme(legend.position = 'bottom')
pca_tcga <- pca_from_projection[['UpdatedExposures_onlyTCGA']]+theme(legend.position = 'bottom')
grid.arrange(pca_all_clinical,
             #pca_from_projection[[2]]+theme(legend.position = 'bottom'),
             pca_tcga,
             ncol=2)
```

```{r, pdf_pca, echo=FALSE}
ggsave(filename = "figures/pca_all.pdf", plot = pca_all_clinical)
ggsave(filename = "figures/pca_tcga.pdf", plot = pca_tcga)
```

### What is different in these 'underrepresented' clinical samples?
I.e., what type of signatures are not represented in the organoids?

Conclusion: it seems as though it's signature 3, the relative abundance of which is never high in organoid samples.

I am comparing

- the barplots of the exposures

- CLR (centered log-ratio) of signature 3 is high in the underrepresented samples

- the ratio of the sums of different signatures, e.g. the ratio of 1+3+5 vs 2+4+6+7.

- ILR (isometric log-ratio) when splitting the dataset into s3 and all other signatures. It is the log-ratio of the exposure to signature 3 and the geometric mean of all other exposures.

```{r, underrepresented, fig.height=5, echo=FALSE, eval=TRUE, fig.width=10}
selected_underrepresented_left <- natgen$UpdatedExposures[which(df_prcomp_exposures$UpdatedExposures$Comp.1 < min(df_prcomp_exposures$UpdatedExposures[df_prcomp_exposures$UpdatedExposures$study == 'Organoid','Comp.1'])),]
selected_underrepresented_right <- natgen$UpdatedExposures[which(df_prcomp_exposures$UpdatedExposures$Comp.1 > max(df_prcomp_exposures$UpdatedExposures[df_prcomp_exposures$UpdatedExposures$study == 'Organoid','Comp.1'])),]

grid.arrange(createBarplot(as(selected_underrepresented_left, 'matrix'), remove_labels = TRUE)+
               ggtitle('Underrepresented (left)')+theme(legend.position = "bottom"),
             createBarplot(as(selected_underrepresented_right, 'matrix'), remove_labels = TRUE)+
               ggtitle('Underrepresented (right)')+theme(legend.position = "bottom"),
             createBarplot(org, remove_labels = TRUE)+ggtitle('Organoids')+theme(legend.position = "bottom"),
             ncol=3)

```


### Loadings

Looking at the loadings. In particular, looking for components in the first and second PC

Respectively, using the first and the second batch of signatures.
```{r, loadings, fig.height=3, echo=FALSE, eval=TRUE}
par(mfrow=c(1,2))
for(i in 1:2){
  barplot(prcomp_all$UpdatedExposures$loadings[,i], main=paste0('Loadings of the\n', c('first', 'second')[i], ' principal component'))
}
```

Signatures 3 and 6 seem to be quite important for the underrepresented groups

# Dendrograms

## Dendrogram based on the signatures
The colour of the labels shows whether there is any zero exposure in the vector of exposures of the sample.

**This section has been deprecated - we are not using robust cle anymore, we are using imputation.**

```{r, princomp_clr_implementation, eval=TRUE, dependson=c('princomp_clr'), warning=FALSE, echo=FALSE}
all_natgen = lapply(natgen, function(i) rbind(i, org))
natgen_clr = lapply(natgen, function(i) as(clr(i), 'matrix'))
names(natgen_clr) = names(natgen)
organoid_metadata <- cbind.data.frame(study=rep('organoids', nrow(org_clr_robustzeroes)), age=NA, age.cat=NA)
rownames(organoid_metadata) <- rownames(org_clr_robustzeroes)
all_metadata <- lapply(natgen_metadata, function(i) rbind(i, organoid_metadata))
all_clr <- lapply(natgen_clr, function(i) rbind(i, org_clr_robustzeroes))
names(all_clr) = names(all_metadata) = names(all_natgen) =  names(natgen)
```


```{r, dendrogram_aitchisondistance_function,echo=FALSE, eval=TRUE, dependson=c('princomp_clr_implementation')}
give_dendrogram <- function(which_natgen){
  rm_infinite <- apply(all_clr[[which_natgen]], 1, function(x) any(is.infinite(x)))
  cat(which(rm_infinite), 'removed due to infinite values')
  all_clr_clean <- all_clr[[which_natgen]][!rm_infinite,]
  
  dendro_all <- as.dendrogram(hclust(dist(all_clr_clean)))
  return(dendro_all)
}

plot_dendro = function(dendro_all, which_natgen, which_label="Symbol", return_tree=FALSE){
  levels_study <- levels(factor(all_metadata[[which_natgen]][labels(dendro_all),'study']))
  levels_study
  which_level_organoids <- which(grepl('organoids', levels_study))
  cols <- rep(NA, length(levels_study))
  colour_organoid = 'blue' #'#88E9A2'
  cols[which_level_organoids] <- colour_organoid
  if(which_natgen == 'ExposuresNatGen'){
    cols[-which_level_organoids] <- c('#FFA07A', '#FA8072', '#E9967A', '#F08080')
  }else if(which_natgen == 'UpdatedExposures'){
    cols[-which_level_organoids] <- c('#FFA07A')
  }
  labels_colors(dendro_all) <- cols[factor(all_metadata[[which_natgen]][labels(dendro_all),'study'])]
  labels_org_bool <- labels_colors(dendro_all) == colour_organoid
  if(which_label == "Symbol"){
    labels(dendro_all)[labels_org_bool] <- rep('○', sum(labels_org_bool))#rep('●', sum(labels_org_bool))
    labels(dendro_all)[!labels_org_bool] <- rep('•', sum(!labels_org_bool))
    labels(dendro_all)[!labels_org_bool] <- rep(NA, sum(!labels_org_bool))
  }else{
    labels(dendro_all)[!labels_org_bool] <- rep(NA, sum(!labels_org_bool))
  }
  cex_labels <- rep(1, length(labels_org_bool))
  cex_labels[labels_org_bool] <- 0.9
  dendro_all <- set(dendro_all, "labels_cex", cex_labels)
  if(return_tree){
    return(dendro_all)
  }else{
    plot(dendro_all, cex=0.4, cex.lab=4, main='Dendrogram based on the exposures\n(Aitchison distance)')
  }
}
```

```{r, dendrogram_aitchisondistance_implementation,echo=FALSE, eval=TRUE, warning=FALSE, echo=FALSE, dependson=c('dendrogram_aitchisondistance_function')}

dendro_UpdatedExposures = give_dendrogram('UpdatedExposures')
plot_dendro(dendro_UpdatedExposures, which_natgen = 'UpdatedExposures')
plot_dendro(dendro_UpdatedExposures, which_natgen = 'UpdatedExposures', which_label="not_symbol")

pdf("figures/dendrogram.pdf", width = 5, height = 4)
plot_dendro(dendro_UpdatedExposures, which_natgen = 'UpdatedExposures')
dev.off()

pdf("figures/dendrogram_with_labels.pdf", width = 10, height = 8)
par(mar=c(8,4,4,4))
plot_dendro(dendro_UpdatedExposures, which_natgen = 'UpdatedExposures', which_label="not_symbol")
dev.off()
```

### Heatmap of the samples in the dendrogram
```{r, heatmap_dendrogram, echo=FALSE, include=FALSE}
heatmap_dendrogram_df = t(all_natgen$UpdatedExposures[rownames(all_natgen$UpdatedExposures)[match(gsub("Organoid ", "", labels(dendro_UpdatedExposures)),rownames(all_natgen$UpdatedExposures))],])
colnames_heatmap_dendrogram_df = colnames(heatmap_dendrogram_df)
# colnames_heatmap_dendrogram_df[1:10]
colnames_heatmap_dendrogram_df[!grepl('Sample',colnames_heatmap_dendrogram_df)] = ""
colnames_heatmap_dendrogram_df[grepl('Sample',colnames_heatmap_dendrogram_df)] = "*"
# colnames_heatmap_dendrogram_df[1:10]
heatmap_dendrogam = pheatmap(heatmap_dendrogram_df, cluster_rows = FALSE, cluster_cols = FALSE,
                             # show_colnames = TRUE,
                             labels_col = colnames_heatmap_dendrogram_df)
heatmap_dendrogam
pdf("figures/heatmap_dendrogam.pdf")
heatmap_dendrogam
dev.off()

extra_expand = .04
p3 = ggplot(melt(heatmap_dendrogram_df), aes(x=Var2, y=Var1, fill=value))+geom_tile()+
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "bottom")+
  scale_fill_gradient2(midpoint=0.5, low="blue", mid="white",
                     high="red", space ="Lab" )+
        scale_x_discrete(expand = c(extra_expand, extra_expand))

dend_data <- dendro_data(dendro_UpdatedExposures, type = "rectangle")
dend_data$labels$label = as.character(dend_data$labels$label)
dend_data$labels$label[!grepl('PDO', dend_data$labels$label)] = ""
p <- ggplot(dend_data$segments) + 
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend))+
  # geom_text(data = dend_data$labels, aes(x, y, label = label),
  #           hjust = 1, angle = 90, size = 3)+
  geom_label_repel(data = dend_data$labels, aes(x, y, label = gsub('Organoid ', '', label)),
            hjust = 0, size = 6, vjust=5)+
  ylim(-3, 15)+
  theme(axis.title.x=element_blank(),
    axis.text.x=element_blank(),
    axis.ticks.x=element_blank(),
    axis.title.y=element_blank(),
    axis.text.y=element_blank(),
    axis.ticks.y=element_blank(),
    panel.grid = element_blank(),
        panel.border = element_blank())+
    scale_x_continuous(expand = c(extra_expand, extra_expand))+
  scale_y_continuous(expand = c(0.5, 0, 0.05, 0))
print(p)

# ggthemr::ggthemr("pale")
p2 = ggplot(melt(heatmap_dendrogram_df), aes(x=Var2, y=value, fill=Var1))+geom_bar(stat='identity')+
    theme(axis.title.x=element_blank(),  legend.title=element_blank(),
          legend.text=element_text(size=18),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),  legend.position = "bottom")+
  scale_fill_brewer(palette="Dark2")+
      # scale_x_discrete(expand = c(extra_expand, extra_expand))+
  guides(fill = guide_legend(nrow = 1))


grid.arrange(p, p2, heights=c(2,1))
pdf("figures/barplot_dendrogam.pdf", height = 7, width = 20)
grid.arrange(p, p2, heights=c(2,1))
dev.off()

grid.arrange(p, p3, heights=c(2,1))
pdf("figures/heatmap_dendrogam2.pdf", height = 7, width = 20)
grid.arrange(p, p3, heights=c(2,1))
dev.off()

# ggthemr::ggthemr_reset()
```

```{r, print_labels_dendrogram}
labels(dendro_UpdatedExposures)[grep('Sample', labels(dendro_UpdatedExposures))]
```


### What type of signatures appear on the branch with no organoids?
We are looking at the split plot below (i.e. the first split). We call 'underrepresented' the samples that fall on the right branch.
```{r, analysis_hclust_split, echo=FALSE, fig.align="center", fig.width=3, fig.height=3}
# taken from https://stackoverflow.com/questions/49336393/r-how-to-extract-all-labels-in-a-certain-node-of-a-dendrogram
accumulator <- list();
myleaves <- function(anode){
    if(!is.list(anode))return(attr(anode,"label"))
    accumulator[[length(accumulator)+1]] <<- (purrr::reduce(lapply(anode,myleaves),c))
}

myleaves(dendro_UpdatedExposures);
ret <- rev(accumulator);
underrepresented_labels = ret[[2]]
labels(dendro_UpdatedExposures)[!(labels(dendro_UpdatedExposures) %in% underrepresented_labels)] = ""
labels(dendro_UpdatedExposures)[(labels(dendro_UpdatedExposures) %in% underrepresented_labels)] = "."
plot(dendro_UpdatedExposures)
```

Which cohorts are these samples from?
```{r, print_underrepresented_labels}
cat(paste0(underrepresented_labels, sep=', '))
```


```{r, analysis_hclust_split2, echo=FALSE, fig.height=4}
brnch_underrepresente_exposures = all_natgen$UpdatedExposures[underrepresented_labels,]
brnch_represented_exposures = all_natgen$UpdatedExposures[! (rownames(all_clr$UpdatedExposures) %in% underrepresented_labels),]
brnch_underrepresented = all_clr$UpdatedExposures[underrepresented_labels,]
brnch_represented = all_clr$UpdatedExposures[! (rownames(all_clr$UpdatedExposures) %in% underrepresented_labels),]

cat('Number of organoids in underrepresented and represented split:' ,
c(sum(grepl('Organoid', rownames(brnch_underrepresented))),
  sum(grepl('Organoid', rownames(brnch_represented)))))
```

```{r, barplots_hclust_split, fig.height=5, fig.width=10, echo=FALSE}
grid.arrange(createBarplot(brnch_underrepresente_exposures, remove_labels = TRUE, verbose = F)+ggtitle('Underrepresented')+theme(legend.position = "bottom"),
             createBarplot(brnch_represented_exposures, remove_labels = TRUE, verbose = F)+ggtitle('Represented')+theme(legend.position = "bottom"), ncol=2)
```

```{r, plot_ggplot_colours, echo=FALSE}
plot_ggplot_colours = function(vector_colours, shape=NULL, vector_shape=NULL){
  if(!is.null(shape)){
  ggplot(cbind(df_prcomp_exposures$UpdatedExposures,group=vector_colours, shpe = vector_shape),
         aes(x=Comp.1, y=Comp.2, col=group, shape=vector_shape))+
      geom_point() +
      ggtitle(paste0("PCA of both datasets with projection,\n dataset: ", which_natgen, "\n groups from dendrogram"))+
      theme_bw()+theme(legend.position = "bottom")
  }
  ggplot(cbind(df_prcomp_exposures$UpdatedExposures,group=vector_colours),
         aes(x=Comp.1, y=Comp.2, col=group))+
      geom_point() +
      ggtitle(paste0("PCA of both datasets with projection,\n dataset: ", which_natgen, "\n groups from dendrogram"))+
      theme_bw()+theme(legend.position = "bottom")
}
```

```{r, num_organoids_split_check, echo=FALSE}
grid.arrange(
ggplot(melt(list(underrepresented=brnch_underrepresented, represented=brnch_represented)), aes(x=Var2, col=L1, group=interaction(L1,Var2), y=value))+geom_boxplot()+
  ggtitle('CLR of each signature, on either side of the split')+theme(legend.position = "bottom"),
plot_ggplot_colours(vector_colours = c('represented', 'underrepresented')[1+as.numeric(rownames(df_prcomp_exposures$UpdatedExposures) %in% underrepresented_labels)]),
ncol=2
)
```

There are two types of population which are not represented:

- On the right of the PCA, right on the barplot above)
  - Relative higher **s3**: the non-represented samples on the right have a very high exposure of s3. Organoids in general don't have such high exposures.
  - Relative lower **s4**

- On the bottom left of the PCA (left of barplot above)
  - **s1**: A fraction of underrepresented samples have extremely low s1

- In general, relative higher s5 in the underrepresented samples (supported by from loadings of PC2, and from the CLR of the samples in the first split of the dendrogram). Organoids have in general a very low exposure of s5. 


These are the exposures for some signatures, in the PCA projection.
```{r, plots_pca_colours, fig.height=10, echo=FALSE}
grid.arrange(plot_ggplot_colours(vector_shape = c('represented', 'underrepresented')[1+as.numeric(rownames(df_prcomp_exposures$UpdatedExposures) %in% underrepresented_labels)],
                    vector_colours = all_natgen$UpdatedExposures[,'s1'] %>% log)+ggtitle('S1 exposure'),
             plot_ggplot_colours(vector_shape = c('represented', 'underrepresented')[1+as.numeric(rownames(df_prcomp_exposures$UpdatedExposures) %in% underrepresented_labels)],
                    vector_colours = all_natgen$UpdatedExposures[,'s2'] %>% log)+ggtitle('S2 exposure'),
plot_ggplot_colours(vector_shape = c('represented', 'underrepresented')[1+as.numeric(rownames(df_prcomp_exposures$UpdatedExposures) %in% underrepresented_labels)],
                    vector_colours = all_natgen$UpdatedExposures[,'s3'] %>% log)+ggtitle('S3 exposure'),
plot_ggplot_colours(vector_shape = c('represented', 'underrepresented')[1+as.numeric(rownames(df_prcomp_exposures$UpdatedExposures) %in% underrepresented_labels)],
                    vector_colours = all_natgen$UpdatedExposures[,'s4'] %>% log)+ggtitle('S4 exposure'),
plot_ggplot_colours(vector_shape = c('represented', 'underrepresented')[1+as.numeric(rownames(df_prcomp_exposures$UpdatedExposures) %in% underrepresented_labels)],
                    vector_colours = all_natgen$UpdatedExposures[,'s5'] %>% log)+ggtitle('S5 exposure'), ncol=2)

```


```{r, logistic_hclust_split, include=FALSE}
add_colnames = function(i){
  colnames(i) = paste0('c', 1:ncol(i))
  i
}
df_logistic = cbind.data.frame(add_colnames(ilr(all_natgen$UpdatedExposures)),
                 bool_underrepresented = as.numeric(rownames(all_natgen$UpdatedExposures) %in% underrepresented_labels))

a = glm(formula = bool_underrepresented ~ c1+c2+c3+c4+c5+c6,
    family=binomial(),
    data = df_logistic)

plot(cbind(a$fitted.values, df_logistic$bool_underrepresented))
```

To make sure this is not due to the type of signatures we are using (since the array ones have more zeros)
```{r, zeros_split, dendrogram, echo=FALSE}
cat('Fraction of samples with any zero in underrepresented: ', sum(apply(all_natgen$UpdatedExposures[as.logical(df_logistic$bool_underrepresented),], 1, function(i) any(i == 0)))/sum(df_logistic$bool_underrepresented),
    '\nFraction of samples with any zero in represented: ',
sum(apply(all_natgen$UpdatedExposures[!as.logical(df_logistic$bool_underrepresented),], 1, function(i) any(i == 0)))/sum(1-df_logistic$bool_underrepresented)
)

```

```{r, compositional}
give_pca = function(data_matrix, center = T, title='', names, names_bool=T, give_loadings=F, print_labels=T, groups=NULL,groups_shape=NULL, nrow_legend=3, size_points=1, print_both_labels=FALSE, group_is_factor=T){
  prcomp_res = prcomp(data_matrix, scale. = TRUE, center = center)
  eigs <- prcomp_res$sdev^2
  if(!names_bool){
    names=NA
  }
  
  if(give_loadings){
    if(!is.null(groups_shape)){
      stop('Groups shape not yet implemented for loadings')
    }
    a = ggplot()+
      geom_point(data=cbind.data.frame(prcomp_res$x[,1:2], names=names), aes(x=PC1, y=PC2), size=size_points)+
      geom_segment(data=cbind.data.frame(prcomp_res$rotation[,1:2], names=paste0('n', 1:ncol(data_matrix))),
                   aes(x=0, y=0, xend=PC1*4, yend=PC2*4), col='red', arrow = arrow(length = unit(0.03, "npc")))+
      labs(x=paste0('PC1 (', round(100*eigs[1]/sum(eigs), 2), '%)' ),
           y=paste0('PC2 (', round(100*eigs[2]/sum(eigs), 2), '%)' ))+ggtitle(title)
    if(print_labels){
      a = a+geom_label_repel(data=cbind.data.frame(prcomp_res$rotation[,1:2], names=paste0('n', 1:ncol(data_matrix))),
                              aes(x=PC1*3, y=PC2*3, label=names), size=3, col='red')
      if(print_both_labels){
        a = a+geom_label_repel(data=cbind.data.frame(prcomp_res$x[,1:2], names=rownames(prcomp_res$x)),
                              aes(x=PC1, y=PC2, label=names), size=3, col='black')
      }
    }
    a
  }else{
    if(!is.null(groups)){
      if(group_is_factor){
        df = cbind.data.frame(prcomp_res$x[,1:2], names=names, groups=as.factor(groups))
      }else{
        df = cbind.data.frame(prcomp_res$x[,1:2], names=names, groups=(groups))
      }
    }else{
      df = cbind.data.frame(prcomp_res$x[,1:2], names=names)
    }
    if(!is.null(groups_shape)){
      df = cbind(df, groups_shape=groups_shape)
    }
    a = ggplot(df,
               aes(x=PC1, y=PC2,label=gsub('Sample ', 'PDO', names)))+
      labs(x=paste0('PC1 (', round(100*eigs[1]/sum(eigs), 2), '%)' ),
           y=paste0('PC2 (', round(100*eigs[2]/sum(eigs), 2), '%)' ))+ggtitle(title)
    if(!is.null(groups)){
      if(!is.null(groups_shape)){
        a = a +geom_point(aes(col=groups, shape=groups_shape), size=size_points)
      }else{
        a = a +geom_point(aes(col=groups), size=size_points)
      }
      a = a + theme(legend.position = "bottom",
            legend.key.size = unit(0.3, "cm"),
            legend.key.width = unit(0.2,"cm"),
            legend.title = element_blank())+
        guides(col=guide_legend(nrow=nrow_legend,byrow=TRUE))
    }else{
      if(!is.null(groups_shape)){
        a = a + geom_point(aes(shape=groups_shape), size=size_points)
      }else{
        a = a + geom_point(size=size_points)
      }
    }

    
    if(print_labels){
      a = a+geom_label_repel(size=3,)
    }
    a
  }
}
```

PCA of a uniform sample from the 3-dimensional simplex (i.e. four parts), with three different transformations
```{r, compositional2, fig.height=3, dependson=c('compositional'), echo=FALSE, warning=FALSE}
grid.arrange(give_pca(MCMCpack::rdirichlet(300, c(1,1,1,1)), title='Untransformed, centered', names_bool = F),
give_pca(MCMCpack::rdirichlet(300, c(1,1,1,1)), center = F, title='Untransformed, uncentered', names_bool = F),
give_pca(as(compositions::clr(MCMCpack::rdirichlet(300, c(1,1,1,1))), 'matrix'), title='CLR, centered', names_bool = F), ncol=3)
```


PCA of organoids with three variations
```{r, compositional3, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(org, title='Untransformed, centered', names=rownames(org)),
give_pca(org, center = F, title='Untransformed, uncentered', names=rownames(org)),
give_pca(as(compositions::clr(org), 'matrix'), title='CLR, centered', names=rownames(org)),
give_pca(as(compositions::clr(impute(org, 1e-2)), 'matrix'), title='CLR+imp, centered', names=rownames(org)), ncol=4)
```

Plot the loadings of the organoids (PCA only with organoids)

```{r, compositional4, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(org, title='Untransformed, centered', names=rownames(org), give_loadings = T),
give_pca(org, center = F, title='Untransformed, uncentered', names=rownames(org), give_loadings = T),
give_pca(as(compositions::clr(org), 'matrix'), title='CLR, centered', names=rownames(org), give_loadings = T), ncol=3)
```


```{r, groupings_for_pca}
grouping_cohort_all_basic = c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))
grouping_cohort_all_basic[grouping_cohort_all_basic != "organoids"] = "primary"
```

- PCA of only-nonzero organoids

```{r, compositional4_onlynonzero, fig.height=3, dependson=c('compositional'), echo=FALSE, fig.width=10}
grid.arrange(give_pca(org[apply(org, 1, function(i) !any(i==0)),], title='Untransformed, centered',
         names=rownames(org[apply(org, 1, function(i) !any(i==0)),]), give_loadings = T),
give_pca(all_natgen[[which_natgen]][apply(all_natgen[[which_natgen]], 1, function(i) !any(i==0)),], title='Untransformed, centered',
names=rownames(all_natgen[[which_natgen]][apply(all_natgen[[which_natgen]], 1, function(i) !any(i==0)),]), give_loadings = F, print_labels = F,
groups=c(natgen_metadata[[which_natgen]]$study[apply(all_natgen[[which_natgen]][1:nrow(natgen_metadata[[which_natgen]]),], 1, function(i) !any(i==0))],
rep('organoids', sum(apply(org, 1, function(i) !any(i==0)))))),
give_pca(all_natgen[[which_natgen]][apply(all_natgen[[which_natgen]], 1, function(i) !any(i==0)),], title='Untransformed, centered',
names=rownames(all_natgen[[which_natgen]][apply(all_natgen[[which_natgen]], 1, function(i) !any(i==0)),]), give_loadings = F, print_labels = F,
groups=grouping_cohort_all_basic[apply(all_natgen[[which_natgen]], 1, function(i) !any(i==0))]), nrow=1)
```

```{r, compositional_allcohorts_onlynonzero_loadings, fig.height=3, dependson=c('compositional'), echo=FALSE, fig.width=3}
give_pca(all_natgen[[which_natgen]][apply(all_natgen[[which_natgen]], 1, function(i) !any(i==0)),], title='Untransformed, centered',
         names=rownames(all_natgen[[which_natgen]][apply(all_natgen[[which_natgen]], 1, function(i) !any(i==0)),]), give_loadings = T)
```


- PCA of all samples, with three variations. CLR is robust.
```{r, compositional5, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(all_natgen[[which_natgen]], title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
                      groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))),
give_pca(all_natgen[[which_natgen]], center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))),
give_pca(as(compositions::clr(all_natgen[[which_natgen]]), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))), ncol=3)
```


```{r, compositional5b, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(all_natgen[[which_natgen]], title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
                      groups=grouping_cohort_all_basic),
give_pca(all_natgen[[which_natgen]], center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=grouping_cohort_all_basic),
give_pca(as(compositions::clr(all_natgen[[which_natgen]]), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=grouping_cohort_all_basic), ncol=3)
```

```{r, compositional5_loadings, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(all_natgen[[which_natgen]], title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = T, print_labels=T,
                      groups=grouping_cohort_all_basic),
give_pca(all_natgen[[which_natgen]], center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = T, print_labels=T,
         groups=grouping_cohort_all_basic),
give_pca(as(compositions::clr(all_natgen[[which_natgen]]), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = T, print_labels=T,
         groups=grouping_cohort_all_basic), ncol=3)
```

- PCA of all samples, with three variations, and with an addition of 1e-4 to all samples. CLR, and only CLR, changes notably.

```{r, compositional6, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(normalise_rw(1e-4+all_natgen[[which_natgen]]), title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
                      groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))),
give_pca(normalise_rw(1e-4+all_natgen[[which_natgen]]), center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))),
give_pca(as(compositions::clr(normalise_rw(1e-4+all_natgen[[which_natgen]])), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))), ncol=3)
```

- PCA of all samples, with three variations, and with an inputation of 1e-4 in all samples. As expected, the results are essentially the same as adding the same value to all elements (zero or non-zero).

```{r, compositional8, fig.height=3, dependson=c('compositional', 'inputation_fun'), echo=FALSE}
grid.arrange(give_pca(impute(all_natgen[[which_natgen]], 1e-4), title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
                      groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))),
give_pca(impute(all_natgen[[which_natgen]], 1e-4), center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))),
give_pca(as(compositions::clr(impute(all_natgen[[which_natgen]], 1e-4)), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))), ncol=3)
```

- PCA of all samples, with three variations, and with an addition of 1e-2 to all samples
```{r, compositional7, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(normalise_rw(1e-2+all_natgen[[which_natgen]]), title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
                      groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))),
give_pca(normalise_rw(1e-2+all_natgen[[which_natgen]]), center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))),
give_pca(as(compositions::clr(normalise_rw(1e-2+all_natgen[[which_natgen]])), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org)))), ncol=3)
```

With imputation of 0.01

```{r, compositional7b, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(normalise_rw(1e-2+all_natgen[[which_natgen]]), title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
                      groups=grouping_cohort_all_basic, nrow_legend=1),
give_pca(normalise_rw(1e-2+all_natgen[[which_natgen]]), center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=grouping_cohort_all_basic, nrow_legend=1),
give_pca(as(compositions::clr(normalise_rw(1e-2+all_natgen[[which_natgen]])), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=grouping_cohort_all_basic, nrow_legend=1),
give_pca(as(compositions::clr(normalise_rw(1e-2+all_natgen[[which_natgen]])), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups=all_natgen[[which_natgen]][,'s3'], group_is_factor=F, groups_shape=NULL, nrow_legend=1), ncol=4)
```

With imputation of 0.01

```{r, compositional7_loading, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(normalise_rw(1e-2+all_natgen[[which_natgen]]), title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = T, print_labels=,
                      groups=grouping_cohort_all_basic, nrow_legend=1),
give_pca(normalise_rw(1e-2+all_natgen[[which_natgen]]), center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = T, print_labels=T,
         groups=grouping_cohort_all_basic, nrow_legend=1),
give_pca(as(compositions::clr(normalise_rw(1e-2+all_natgen[[which_natgen]])), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = T, print_labels=T,
         groups=grouping_cohort_all_basic, nrow_legend=1), ncol=3)
```

s1 seems not to be of importance in the loadings of this last PCA. Use it as baseline for PCA (good, too, because it's almost always strictly positive).
```{r, barplot_organoids_alr, fig.height=6.5,message=FALSE, echo=FALSE,warning=FALSE}
createBarplot((org/org[,1])[,-1], remove_labels = TRUE, order_labels = names(sort(org[,1]))) + 
    labs(y='ALR with s1 baseline')+facet_wrap(.~Var2, ncol=1, scales='free_y')+
  ggtitle('ALR with s1 as baseline')
```

PCA with imputation of 0.01, as in the dendrogram
```{r, pca_imputation, fig.height=4, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(as(compositions::clr(impute(org, 1e-2)), 'matrix'), title='CLR+imp, centered', names=rownames(org)),
give_pca(as(compositions::clr(impute(org, 1e-2)), 'matrix'), title='CLR+imp, centered', names=rownames(org), give_loadings = T), ncol=2)
```

PCA of ALR with imputation of 0.01, as in the dendrogram
```{r, pca_imputationALR, fig.height=4, dependson=c('compositional'), echo=FALSE}
alr_first_cat <- function(i){
  (log(i)/log(i)[,1])[,-1]
}
grid.arrange(give_pca(as((alr_first_cat(impute(impute(org, 1e-2), 1e-2))), 'matrix'), title='ALR+imp, centered', names=rownames(org)),
give_pca(as(alr_first_cat(impute(org, 1e-2)), 'matrix'), title='ALR+imp, centered', names=rownames(org), give_loadings = T), ncol=2)
```


```{r, pairs_alr}
pairs( (org/org[,1])[,-1])
```

```{r, scatterplots}
grid.arrange(ggplot(cbind.data.frame(s2=org[,'s2'], s4=org[,'s4'], lab=rownames(org)), aes(x=s2, y=s4, label=lab))+geom_point()+geom_label_repel(),
ggplot(cbind.data.frame(s2s1=org[,'s2']/org[,'s1'], s4s1=org[,'s4']/org[,'s1'], lab=rownames(org)), aes(x=s2s1, y=s4s1, label=lab))+geom_point()+geom_label_repel(), nrow=1)
```

```{r, pairs_alr_cohort}
pairs( (all_natgen[[which_natgen]]/all_natgen[[which_natgen]][,1])[,-1])
```

```{r, pairs_alr_cohort_no_s5}
pairs( (normalise_rw(all_natgen[[which_natgen]][,-5])/all_natgen[[which_natgen]][,1])[,-1])
```

```{r, s2_and_s4_and_s6_organoids, fig.height=2, fig.width=4}
df_correlations_exposures_organoids = data.frame(ALR_bsS1_s2=org[,2]/org[,1],
                  ALR_bsS1_s4=org[,4]/org[,1],
                  ALR_bsS1_s6=org[,6]/org[,1])
grid.arrange(ggplot(df_correlations_exposures_organoids, aes(x=ALR_bsS1_s2,y=ALR_bsS1_s4))+
               geom_point()+geom_smooth(method = "lm")+labs(x='ALR_s1(s2)', y='ALR_s1(s4)'),
             ggplot(df_correlations_exposures_organoids, aes(x=ALR_bsS1_s2,y=ALR_bsS1_s6))+
               geom_point()+geom_smooth(method = "lm")+labs(x='ALR_s1(s2)', y='ALR_s1(s6)'), nrow=1)
```


```{r, barplot_amalgamations, fig.height=3}
org_rename = org
rownames(org_rename) = gsub("Sample ", "PDO", rownames(org))
grid.arrange(createBarplot(cbind(org_rename[,c(1,3,5,7)], sum=rowSums(org_rename[,c(2,4,6)])), remove_labels = FALSE, order_labels = names(sort(org_rename[,1]))) + 
    labs(y='Exposure')+ ggtitle('Exposures for the organoids')+theme(axis.text.x = element_text(angle = 45))+theme(legend.position = "bottom"),
createBarplot(normalise_rw(cbind(org_rename[,c(1,3,7)], sum=rowSums(org_rename[,c(2,4,6)]))), remove_labels = FALSE, order_labels = names(sort(org_rename[,1]))) + 
    labs(y='Exposure')+ ggtitle('Exposures for the organoids')+theme(axis.text.x = element_text(angle = 45))+theme(legend.position = "bottom"), nrow=1)
grid.arrange(give_pca(normalise_rw(cbind(org_rename[,c(1,3,7)], sum=rowSums(org_rename[,c(2,4,6)]))), names=rownames(org_rename)),
             give_pca(as(compositions::clr(normalise_rw(cbind(org_rename[,c(1,3,7)], sum=rowSums(org_rename[,c(2,4,6)])))), 'matrix'), names=rownames(org_rename)),
             give_pca(as(compositions::clr(normalise_rw(cbind(org_rename[,c(1,3,7)], sum=rowSums(org_rename[,c(2,4,6)])))), 'matrix'), names=rownames(org_rename),
                      give_loadings = T), nrow=1)
```


Note: s3 and s4 are consistently shown in the same PC axis, in opposite directions.

```{r, s2_and_s4_and_s6_cohorts, fig.height=2, fig.width=4}
df_correlations_exposures_cohorts = data.frame(ALR_bsS1_s2=all_natgen[[which_natgen]][,2][1:nrow(natgen_metadata[[which_natgen]])]/all_natgen[[which_natgen]][,1][1:nrow(natgen_metadata[[which_natgen]])],
           ALR_bsS1_s4=all_natgen[[which_natgen]][,4][1:nrow(natgen_metadata[[which_natgen]])]/all_natgen[[which_natgen]][,1][1:nrow(natgen_metadata[[which_natgen]])],
          ALR_bsS1_s6=all_natgen[[which_natgen]][,6][1:nrow(natgen_metadata[[which_natgen]])]/all_natgen[[which_natgen]][,1][1:nrow(natgen_metadata[[which_natgen]])],
                  colour=natgen_metadata[[which_natgen]]$study[1:nrow(natgen_metadata[[which_natgen]])]
                  )
grid.arrange(ggplot(df_correlations_exposures_cohorts, aes(x=ALR_bsS1_s2,y=ALR_bsS1_s4))+
               geom_point()+geom_smooth(method = "lm")+labs(x='ALR_s1(s2)', y='ALR_s1(s4)'),
             ggplot(df_correlations_exposures_cohorts, aes(x=ALR_bsS1_s2,y=ALR_bsS1_s6))+
               geom_point()+geom_smooth(method = "lm")+labs(x='ALR_s1(s2)', y='ALR_s1(s6)'), nrow=1)
```

- Inputation of 1e-2, and without s5 (first three plots), and with robust CLR wihout imputation (last plot)
```{r, compositional_without_s5, fig.height=3, dependson=c('compositional'), echo=FALSE}
grid.arrange(give_pca(normalise_rw(impute(all_natgen[[which_natgen]][,-5], 1e-2)), title='Untransformed, centered',
                      names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
                      groups_shape=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org))), groups = grouping_cohort_all_basic),
give_pca(normalise_rw(impute(all_natgen[[which_natgen]][,-5], 1e-2)), center = F, title='Untransformed, uncentered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups_shape=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org))), groups = grouping_cohort_all_basic),
give_pca(as(compositions::clr(normalise_rw(impute(all_natgen[[which_natgen]][,-5], 1e-2))), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups_shape=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org))), groups = grouping_cohort_all_basic),
give_pca(as(compositions::clr(normalise_rw(all_natgen[[which_natgen]][,-5])), 'matrix'), title='CLR, centered',
         names=c(rownames(all_natgen[[which_natgen]])), give_loadings = F, print_labels=F,
         groups_shape=c(natgen_metadata[[which_natgen]]$study, rep('organoids', nrow(org))), groups = grouping_cohort_all_basic), ncol=4)
```

Pretty interesting plot, as it seems to show four driving forces whicc are orthogonal two-on-two. n1 (s1) and s2 (s3) are anticorrelated and driving most of the variance in organoids. The sum of s2,4,6, is orthogonal to both s1 and s3, and causes most subsequent variation.
```{r, interesating_pca, dependson=c('compositional'), echo=FALSE, message=FALSE, fig.height=7}
amalgamation_interesting = normalise_rw(cbind(org_rename[,c(1,3,7)], sum=rowSums(org_rename[,c(2,4,6)])))
interesting_data = as(compositions::clr(amalgamation_interesting), 'matrix')
prcomp_res_interesting_data = prcomp(interesting_data, scale. = TRUE, center = TRUE)

df_exposures_pca = cbind.data.frame(melt(org),
                 pos=(amalgamation_interesting[,'s3']/amalgamation_interesting[,'s1'])[match(melt(org)$Var1,
                                                                                             names((amalgamation_interesting[,'s3']/amalgamation_interesting[,'s1'])))])
df_exposures_pca = df_exposures_pca[!is.infinite(df_exposures_pca$pos),]


first_col = plot_grid(ggplot(cbind.data.frame(pc1=prcomp_res_interesting_data$x[,1],
           ratio=amalgamation_interesting[,'s3']/amalgamation_interesting[,'s1']))+geom_point(aes(x=pc1, y=ratio))+labs(x='', y='LogR s3/s1'),
           # ggplot(),
           give_pca(data_matrix = interesting_data,
         names=rownames(org_rename), give_loadings = T, print_labels = T, print_both_labels=T)+theme(title = element_blank())+labs(x='PC1', y='PC2'),
         ncol = 1, rel_heights = c(2, 3))
second_col = plot_grid(ggplot(df_exposures_pca,
       aes(x=pos, y=value, fill=Var2))+geom_bar(stat = 'identity', width=.05)+  coord_flip()+
         scale_fill_brewer(palette="Dark2")+labs(y='Exposure')+guides(fill=FALSE)
, ggplot(cbind.data.frame(ratio=amalgamation_interesting[,'sum']/(amalgamation_interesting[,'s1']+amalgamation_interesting[,'s3']),
                                                     pc2=prcomp_res_interesting_data$x[,2]))+geom_point(aes(x=ratio, y=pc2))+
                         labs(x='LogR (s2+4+6)/(s1+3)'),
                       ncol = 1, rel_heights = c(2, 3))
plot_grid(first_col, second_col, ncol = 2, rel_widths = c(3, 2))

createBarplot(rename_rows(org, gsub('Sample ', 'PDO', rownames(org))), remove_labels = FALSE, order_labels = gsub('Sample ', 'PDO', names(sort(org[,1])))) + 
    scale_fill_brewer(palette="Dark2")+labs(y='Exposure')+
  ggtitle('Exposures for the organoids')+labs(x='')+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```

Does the same happen in the cohorts?

```{r, interesting_pca_cohorts}
give_pca(data_matrix = as(compositions::clr(normalise_rw(cbind(natgen[[which_natgen]][,c(1,3,7)],
                                                                sum=rowSums(natgen[[which_natgen]][,c(2,4,6)])))), 'matrix'),
         names=rownames(natgen[[which_natgen]]), give_loadings = T, print_labels = T, print_both_labels=F)
```

### Some comments on the PCAs
- Whenever an imputation for zero values is used, a large fraction of organoid samples appear as outliers, and so do the other TCGA samples (which are the other samples that contain zeros)
- If the robust CLR PCA is used, there is no such distinction
- If the raw values are used (which I think there should be no problem using), there is no big difference either.

## Hierarchical clustering

## Plot showing differences in amalgamation ratios

```{r, amalgamation_ratios_fun, echo=FALSE}
remove_organoids = function(df){
  df[!grepl('Sample ', rownames(df)),]
}

give_zero = function(a) a[a == 0]
give_infty = function(a) a[is.infinite(a)]
give_nonzero = function(a) a[(a > 0) & !is.infinite(a)]
```

```{r, amalgamation_ratios_implementation, dependson=c('amalgamation_ratios_fun'), echo=FALSE, fig.height=2}
for(j in 1:7){
  .orgs = org[,j] / rowSums(org[,(1:7)[!c(1:7 %in% j)]])
  .orgs_zero = give_zero(.orgs)
  .orgs_infty = give_infty(.orgs)
  .orgs_nonzero = give_nonzero(.orgs)
  .cohort = remove_organoids(natgen[[which_natgen]])[,j] / rowSums(remove_organoids(natgen[[which_natgen]])[,(1:7)[!c(1:7 %in% j)]])
  .cohort_zero = give_zero(.cohort)
  .cohort_infty = give_infty(.cohort)
  .cohort_nonzero = give_nonzero(.cohort)
  
  grid.arrange(
  ggplot(melt(cbind.data.frame(zero=c(length(.orgs_zero), length(.cohort_zero)),
                          total=c(length(c(.orgs_infty,.orgs_nonzero)), length(c(.cohort_infty,.cohort_nonzero))),
                          cohort=c('Organoids', ' Cohort')), id.vars = "cohort"), aes(x=cohort, fill=variable, y=value))+geom_bar(stat = "identity")+
    facet_wrap(.~cohort, scales = "free")+theme(legend.position = "bottom", legend.title = element_blank(), legend.key = element_blank(), legend.key.width = unit(.01, "cm"), legend.key.height = unit(.1, "cm"), strip.background = element_blank(), strip.text.x = element_blank())+labs(x='', y=''),
  ggplot(cbind.data.frame(x=c(.cohort_nonzero, .orgs_nonzero), y=c(rep("Cohort", length(.cohort_nonzero)), rep("Organoids", length(.orgs_nonzero)))))+
    geom_density(aes(x=log(x), col=y))+theme(legend.position = "bottom", legend.title = element_blank(), legend.key.width = unit(.3, "cm"), legend.key.height = unit(.1, "cm"))+scale_color_manual(values=c("#56B4E9", "#E69F00")),
  ggplot(melt(cbind.data.frame(zero=c(length(.orgs_infty), length(.cohort_infty)),
                               total=c(length(c(.orgs_zero,.orgs_nonzero)), length(c(.cohort_zero,.cohort_nonzero))),
                               cohort=c('Organoids', ' Cohort')), id.vars = "cohort"), aes(x=cohort, fill=variable, y=value))+geom_bar(stat = "identity")+
    facet_wrap(.~cohort, scales = "free")+theme(legend.position = "bottom", legend.title = element_blank(), legend.key = element_blank(), legend.key.width = unit(.01, "cm"), legend.key.height = unit(.1, "cm"), strip.background = element_blank(), strip.text.x = element_blank())+labs(x='', y=''),
  ncol=3, widths=c(0.2, 0.6, 0.2), top=paste0('Signature ', j))
}
```

```{r, hierarchical_compositional_2, dependson=c('hierarchical_compositional'), fig.width=12}
par(mfrow=c(1,2))
dendroraw = give_dendrogram_generalised(all_natgen[[which_natgen]], modify_labels = F, keep_only_PDO = T)
dendroclr = give_dendrogram_generalised(as(compositions::clr(all_natgen[[which_natgen]]), 'matrix'), modify_labels = F, keep_only_PDO=T)
par(mfrow=c(1,4), mar=c(0.2,0.2,0.2,0.2))
dendroraw_pdo = give_dendrogram_generalised(all_natgen[[which_natgen]][grepl('PDO', rownames(all_natgen[[which_natgen]])),], modify_labels=F, keep_only_PDO = T)
dendroclr_pdo = give_dendrogram_generalised(as(compositions::clr(all_natgen[[which_natgen]][grepl('PDO', rownames(all_natgen[[which_natgen]])),]), 'matrix'), modify_labels=F, keep_only_PDO = T)
dendroimput_pdo = give_dendrogram_generalised(impute(all_natgen[[which_natgen]][grepl('PDO', rownames(all_natgen[[which_natgen]])),], 1e-2), modify_labels=F, keep_only_PDO = T)
dendroimputclr_pdo = give_dendrogram_generalised(as(compositions::clr(impute(all_natgen[[which_natgen]][grepl('PDO', rownames(all_natgen[[which_natgen]])),], 1e-2)), 'matrix'), modify_labels=F, keep_only_PDO = T)
dendroimputclr_all = give_dendrogram_generalised(as(compositions::clr(impute(all_natgen[[which_natgen]], 1e-2)), 'matrix'), modify_labels=F, keep_only_PDO = F)
```

Number of samples for this clustering analysis:

```{r, num_samples_cluster}
dim(all_natgen[[which_natgen]])
```

```{r, raw_hclust, dependson=c('dendrogram_gen_impute', 'hierarchical_compositional')}

dend_data_inputclr <- dendro_data(dendroimputclr_all, type = "rectangle")
dend_data_inputclr$labels$label = as.character(dend_data_inputclr$labels$label)
dend_data_inputclr$labels$label[!grepl('PDO', dend_data_inputclr$labels$label)] = ""
p_v2 <- ggplot(dend_data_inputclr$segments) +
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend))+
  # geom_text(data = dend_data$labels, aes(x, y, label = label),
  #           hjust = 1, angle = 90, size = 3)+
  geom_label_repel(data = dend_data_inputclr$labels, aes(x, y, label = gsub('Organoid ', '', label)),
            hjust = 0, size = 3, vjust=0, nudge_y = -2)+
  ylim(-3, 15)+
  theme_bw()+
  theme(axis.title.x=element_blank(),
    axis.text.x=element_blank(),
    axis.ticks.x=element_blank(),
    axis.title.y=element_blank(),
    axis.text.y=element_blank(),
    axis.ticks.y=element_blank(),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())+
    scale_x_continuous(expand = c(extra_expand, extra_expand))+
  scale_y_continuous(expand = c(0.5, 0, 0.05, 0))
# print(p)

heatmap_dendrogram_df_inputclr = t(all_natgen$UpdatedExposures[rownames(all_natgen$UpdatedExposures)[match(gsub("Organoid ", "", labels(dendroimputclr_all)),rownames(all_natgen$UpdatedExposures))],])
# heatmap_dendrogram_df_inputclr = colnames(heatmap_dendrogram_df)
# heatmap_dendrogram_df_inputclr[!grepl('Sample',heatmap_dendrogram_df_inputclr)] = ""
# heatmap_dendrogram_df_inputclr[grepl('Sample',heatmap_dendrogram_df_inputclr)] = "*"

# ggthemr::ggthemr("pale")
extra_expand_v2 = .040
p2_inputclr = ggplot(melt(heatmap_dendrogram_df_inputclr), aes(x=Var2, y=value, fill=Var1))+geom_bar(stat='identity')+theme_bw()+
    theme(axis.title.x=element_blank(),  legend.title=element_blank(),
          legend.text=element_text(size=10),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),  legend.position = "bottom",
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.border = element_blank())+
  scale_fill_brewer(palette="Dark2")+
      scale_x_discrete(expand = c(extra_expand_v2, extra_expand_v2))+
  guides(fill = guide_legend(nrow = 1))

p2_inputclr_with_ticks = ggplot(melt(heatmap_dendrogram_df_inputclr), aes(x=Var2, y=value, fill=Var1))+geom_bar(stat='identity')+theme_bw()+
    theme(axis.title.x=element_blank(),  legend.title=element_blank(),
          legend.text=element_text(size=10),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        legend.position = "bottom",
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.border = element_blank())+
  scale_fill_brewer(palette="Dark2")+
      scale_x_discrete(expand = c(0, extra_expand_v2))+
  guides(fill = guide_legend(nrow = 1))
# 

pdf("figures/barplot_dendrogam_impute10emin2_clr.pdf", width=10, height = 4)
grid.arrange(p_v2, p2_inputclr, heights=c(2,1))
dev.off()

saveRDS(p_v2, "robjects/dendrograminputclr.RDS")
saveRDS(dendroimputclr_all, "robjects/dendrograminputclr_tree.RDS")
saveRDS(p2_inputclr, "robjects/heatmapinputclr.RDS")
saveRDS(p2_inputclr_with_ticks, "robjects/heatmapinputclr_with_ticks.RDS")

grid.arrange(p_v2, p2_inputclr, heights=c(2,1))
# grid.arrange(p, p3, heights=c(2,1))
# grid.arrange(p, p3, heights=c(2,1))

```

Now doing the same with a different imputation vlaue
```{r, raw_hclust_lowerinput, dependson=c('dendrogram_gen_impute', 'hierarchical_compositional')}
give_dendrogram_from_imputation(1/250)
give_dendrogram_from_imputation(1/100)

saveRDS(all_natgen[[which_natgen]], file = paste0("robjects/allnatgen_", which_natgen, ".RDS"))

```



```{r, tanglegram, eval=FALSE, dependson='hierarchical_compositional'}
library(dendextend) # for comparing two dendrograms
dend1comparison <- as.dendrogram (dendroraw_pdo)
dend2comparison <- as.dendrogram (dendroclr_pdo)
dend3comparison <- as.dendrogram (dendroimput_pdo)
dend4comparison <- as.dendrogram (dendroimputclr_pdo)

tanglegram(dend1comparison, dend2comparison)
tanglegram(dend1comparison, dend3comparison)
tanglegram(dend1comparison, dend4comparison)
tanglegram(dend2comparison, dend4comparison)
```


## Comparison of exposures between exposures clusterings, and with and RNA-Seq data

The imputation+clr dendrograms are not the same when considering only the organoids than when using all samples from TCGA, but in general the two agree in which organoids get clustered and the overal structure of the dendrogram.

```{r, dendrogram_gen_impute, eval=TRUE, dependson=c('hierarchical_compositional')}
# dendroimputclr_all = give_dendrogram_generalised(as(compositions::clr(impute(all_natgen[[which_natgen]], 1e-2)), 'matrix'), modify_labels=F, keep_only_PDO = F)
dendroimputclrimpute_org <- give_dendrogram_generalised(as(compositions::clr(impute(all_natgen[[which_natgen]][grepl('PDO', rownames(all_natgen[[which_natgen]])),], 1e-2)), 'matrix'), modify_labels=F, keep_only_PDO = T, plot_dendro=F)
```

```{r, tanglegram_with_rnaseq, eval=TRUE, dependson=c('dendrogram_gen_impute', 'hierarchical_compositional')}

hclust_rnaseq <- readRDS("../RNASeq_DE_resistant_sensitive/objects/hclust_rnaseq.RDS")
tanglegram(as.dendrogram (dendroimputclrimpute_org), as.dendrogram(dendroimputclr_all), main='PDO-only clustering vs all exposures')
tanglegram(as.dendrogram (dendroimputclrimpute_org), as.dendrogram(hclust_rnaseq), main='PDO-only clustering vs RNA-Seq clustering')
tanglegram(as.dendrogram (dendroimputclr_all), as.dendrogram(hclust_rnaseq), main='All exposures clustering vs RNA-Seq clustering')

```

Now with TPM
```{r, tanglegram_with_rnaseq_TPM, eval=TRUE, dependson=c('dendrogram_gen_impute', 'hierarchical_compositional')}

hclust_rnaseq_TPM <- readRDS("../RNASeq_DE_resistant_sensitive/objects/hclust_rnaseq_TPM.RDS")
tanglegram(as.dendrogram (dendroimputclrimpute_org), as.dendrogram(hclust_rnaseq_TPM), main='PDO-only clustering vs RNA-Seq TPM clustering')
tanglegram(as.dendrogram (dendroimputclr_all), as.dendrogram(hclust_rnaseq_TPM), main='All exposures clustering vs RNA-Seq TPM clustering')
tanglegram(as.dendrogram (hclust_rnaseq), as.dendrogram(hclust_rnaseq_TPM), main='RNA-Seq clustering vs RNA-Seq TPM clustering')

```


# Analysis of CN profiles
additional genomic data comparing the tumours to the organoids in terms of ploidy, number of rearrangements and any other things that you think could be relevant

## Load the segments

### Distribution of features
```{r, read_features}
pcawg_CN_features = readRDS("data/pcawg_CN_features.rds")
tcga_CN_features = readRDS("data/tcga_CN_features.rds")

BriTROC_absolute_copynumber = readRDS("../../cnsignatures/manuscript_Rmarkdown/data/BriTROC_absolute_copynumber.rds")
BriTROC2_CN_features = readRDS("data/6_TCGA_Signatures_on_BRITROC/0_BRITROC_absolute_CN.rds")

organoids_absolute_copynumber = readRDS("data/organoid_absolute_CN.rds")
sampleNames(organoids_absolute_copynumber) = names_orgs$`new name`[match(gsub("org", "", sampleNames(organoids_absolute_copynumber)), names_orgs$`old name`)]
organoids_CN_features = extractCopynumberFeatures(organoids_absolute_copynumber)

BriTROC_CN_features = readRDS("data/BriTROC_CN_features.rds")
```


The number of segments can be taken either from segsize (first column) or from copynumber (last column). This is just for PCAWG and TCGA! Not for BriTROC. Any idea why this is the case?

** Note: I am plotting this as the log!**

** Note 2: I am pooling together segments from several samples and analysing them all together! I.e. I have not averaged over samples **

```{r, segment_sizes_df, echo=FALSE}
df_features =  lapply(names(organoids_CN_features), function(name_it_features){list(organoids=organoids_CN_features[[name_it_features]] %>% dplyr::select(2) %>%
                              unlist %>% as.numeric %>% log,
                            BriTROC=BriTROC_CN_features[[name_it_features]] %>% dplyr::select(2) %>%
                              unlist %>% as.numeric %>% log,
                            PCAWG=pcawg_CN_features[[name_it_features]] %>% dplyr::select(2) %>%
                              unlist %>% as.numeric %>% log,
                            TCGA=tcga_CN_features[[name_it_features]] %>% dplyr::select(2) %>%
                              unlist %>% as.numeric %>% log)})
names(df_features) = c('Segment size', 'Number of breakpoints per 10Mb', 'Oscillating copy number', 'Number of breakpoints per chromosome arm', 'Changepoint', 'Copy number of segment')
```

```{r, segment_sizes_plot, echo=FALSE}
## Distribution of the segment sizes
distribs_features = lapply(names(df_features), function(name_it_features){
  give_joint_histogram(df_features[[name_it_features]], no_colour=FALSE)+ggtitle(paste0(name_it_features, ' (log)'))+ guides(fill=FALSE)
})

```


```{r, nsegments_pcawg_plot, dependson=c('nsegments_pcawg'), fig.width=12, fig.height=9, warning=FALSE, echo=FALSE, message=FALSE}
nsegments_pcawg_plot = grid.arrange(distribs_features[[1]], distribs_features[[2]],
             distribs_features[[3]], distribs_features[[4]],
             distribs_features[[5]], distribs_features[[6]], ncol=3)
grid.draw(nsegments_pcawg_plot)

pdf("figures/feature_distributions.pdf", width = 14, height = 10)
grid.draw(nsegments_pcawg_plot)
dev.off()
```

<!-- ### Tests for equality of means of the distribution of features -->

<!-- - Segment size -->

<!-- ```{r, tests_for_features_plot_segment_size0} -->
<!-- names(df_features) -->
<!-- sapply(df_features, names) -->
<!-- ``` -->

<!-- ```{r, tests_for_features_plot_segment_size} -->
<!-- grid.arrange(ggplot(melt(list(organoids=df_features$`Segment size`$organoids, -->
<!--                               patients=unlist(df_features$`Segment size`[c("BriTROC", "PCAWG", "TCGA")]))), aes(x=exp(value), group=L1, col=(L1)))+geom_density()+theme(legend.position='bottom'), -->
<!--                   ggplot(melt(list(df_features$`Segment size`$organoids, unlist(df_features$`Segment size`[c("BriTROC", "PCAWG", "TCGA")]))), aes(x=(value), col=as.factor(L1)))+geom_density()+theme(legend.position='bottom')+geom_density()+theme(legend.position='bottom'), -->
<!--              ncol=2) -->
<!-- ``` -->

<!-- ```{r, tests_for_features_plot_segment_size_2} -->
<!-- t.test(unlist(df_features$`Segment size`[c("BriTROC", "PCAWG", "TCGA")]), -->
<!--        df_features$`Segment size`[["organoids"]]) -->
<!-- ``` -->

<!-- - Number of breakpoints per 10Mb -->

<!-- ```{r, looking_at_num_bp_per_10mb} -->
<!-- head(exp(df_features$`Number of breakpoints per 10Mb`$organoids)) -->
<!-- ``` -->

<!-- ```{r, tests_for_features_plot_numbreakpointds_per10mb_plots} -->
<!-- grid.arrange(ggplot(melt(df_features$`Number of breakpoints per 10Mb`), aes(x=exp(value), fill=L1))+geom_histogram()+theme(legend.position='bottom')+facet_wrap(.~L1, scales='free_y')+ggtitle('Raw # bp per 10Mb'), -->
<!--                   ggplot(melt(df_features$`Number of breakpoints per 10Mb`), aes(x=(value), fill=L1))+geom_histogram()+theme(legend.position='bottom')+facet_wrap(.~L1, scales='free_y')+ggtitle('Log # bp per 10Mb'), -->
<!--              ncol=2) -->
<!-- ``` -->

<!-- ```{r, tests_for_features_plot_numbreakpointds_per10mb} -->
<!-- glm_um_bp10mb = rbind.data.frame( -->
<!--   cbind.data.frame(num=exp(df_features$`Number of breakpoints per 10Mb`$organoids), -->
<!--                    bool=rep(0,length(df_features$`Number of breakpoints per 10Mb`$organoids))), -->
<!--   cbind.data.frame(num=exp(unlist(df_features$`Number of breakpoints per 10Mb`[c("BriTROC", "PCAWG", "TCGA")])), -->
<!--                    bool=rep(1,length(unlist(df_features$`Number of breakpoints per 10Mb`[c("BriTROC", "PCAWG", "TCGA")]))))) -->
<!-- table(glm_um_bp10mb[,2]) -->
<!-- reduced_nb_num_bp10mb = glm.nb(formula = num ~ 1, data = glm_um_bp10mb) -->
<!-- full_nb_nb_num_bp10mb = glm.nb(formula = num ~ bool, data = glm_um_bp10mb) -->
<!-- res_LRT_nb_num_bp10mb = anova(reduced_nb_num_bp10mb, full_nb_nb_num_bp10mb, test = "LRT") -->
<!-- res_LRT_nb_num_bp10mb -->

<!-- ``` -->

### Tests for equality of means of the distribution of features (average of segments within a sample)

- I have computed the average value for each feature for each sample. Then I have compared the distribution of means of the patient cohorts all together, versus the distribution of means of the organoids
- This is different from the approach above, where we were pooling segments for all samples (i.e. not keeping patient information)
- In all cases I have log-transformed the data, which ensues normality, to compute a p-value for the difference in means
- I am using the default r t-test, which is the Welch t-test, which does not assume equality of variances
- In all cases there is no statistical significance between organoids the cohorts, indicating a similar distribution (at least when it comes to their means)
- The only feature which is truly problematic is copy number, which very evidently shows a bimodal distribution (since there are the normal segments, or segments of copy number 1, and the amplified segments, which appear as two populations)

```{r, tests_features_patient_averages, fig.height=4}

distrib_segsize = create_distrib_df('segsize', 'value')
distrib_bp10MB = create_distrib_df('bp10MB', 'value')
distrib_osCN = create_distrib_df('osCN', 'value')
distrib_bpchrarm = create_distrib_df('bpchrarm', 'ct1')
distrib_changepoint = create_distrib_df('changepoint', 'value')
distrib_copynumber = create_distrib_df('copynumber', 'value')

#------------------------------------------------------------------------------------------------#

## 1/6 breakpoints per 10MB
grid.arrange(give_joint_histogram(list(distrib_bp10MB[['org']]$`mean(ct1_num)`,
                          distrib_bp10MB[['pcawg']]$`mean(ct1_num)`,
                          distrib_bp10MB[['tcga']]$`mean(ct1_num)`,
                          distrib_bp10MB[['BriTROC']]$`mean(ct1_num)`), no_colour=FALSE),
give_joint_histogram(list(distrib_bp10MB[['org']]$`mean(ct1_num)` %>% log,
                          distrib_bp10MB[['pcawg']]$`mean(ct1_num)` %>% log,
                          distrib_bp10MB[['tcga']]$`mean(ct1_num)` %>% log,
                          distrib_bp10MB[['BriTROC']]$`mean(ct1_num)` %>% log), no_colour=FALSE)+ggtitle('Log transform'), ncol=2)

t.test(distrib_bp10MB[['org']]$`mean(ct1_num)` %>% log,
       c(distrib_bp10MB[['pcawg']]$`mean(ct1_num)` %>% log,
         distrib_bp10MB[['tcga']]$`mean(ct1_num)` %>% log,
         distrib_bp10MB[['BriTROC']]$`mean(ct1_num)` %>% log))

#------------------------------------------------------------------------------------------------#
## 2/6 segment size
grid.arrange(give_joint_histogram(list(distrib_segsize[['org']]$`mean(ct1_num)`,
                          distrib_segsize[['pcawg']]$`mean(ct1_num)`,
                          distrib_segsize[['tcga']]$`mean(ct1_num)`,
                          distrib_segsize[['BriTROC']]$`mean(ct1_num)`), no_colour=FALSE)+ggtitle('Raw'),
give_joint_histogram(list(distrib_segsize[['org']]$`mean(ct1_num)` %>% log,
                          distrib_segsize[['pcawg']]$`mean(ct1_num)` %>% log,
                          distrib_segsize[['tcga']]$`mean(ct1_num)` %>% log,
                          distrib_segsize[['BriTROC']]$`mean(ct1_num)` %>% log), no_colour=FALSE)+ggtitle('Log transform'), ncol=2)

t.test(distrib_segsize[['org']]$`mean(ct1_num)` %>% log,
       c(distrib_segsize[['pcawg']]$`mean(ct1_num)` %>% log,
         distrib_segsize[['tcga']]$`mean(ct1_num)` %>% log,
         distrib_segsize[['BriTROC']]$`mean(ct1_num)` %>% log))

#------------------------------------------------------------------------------------------------#
## 3/6 oscillating CN
grid.arrange(give_joint_histogram(list(distrib_osCN[['org']]$`mean(ct1_num)`,
                          distrib_osCN[['pcawg']]$`mean(ct1_num)`,
                          distrib_osCN[['tcga']]$`mean(ct1_num)`,
                          distrib_osCN[['BriTROC']]$`mean(ct1_num)`), no_colour=FALSE)+ggtitle('Raw'),
give_joint_histogram(list(distrib_osCN[['org']]$`mean(ct1_num)` %>% log,
                          distrib_osCN[['pcawg']]$`mean(ct1_num)` %>% log,
                          distrib_osCN[['tcga']]$`mean(ct1_num)` %>% log,
                          distrib_osCN[['BriTROC']]$`mean(ct1_num)` %>% log), no_colour=FALSE)+ggtitle('Log transform'), ncol=2)

t.test(distrib_osCN[['org']]$`mean(ct1_num)` %>% log,
       remove_infty(c(distrib_osCN[['pcawg']]$`mean(ct1_num)` %>% log,
         distrib_osCN[['tcga']]$`mean(ct1_num)` %>% log,
         distrib_osCN[['BriTROC']]$`mean(ct1_num)` %>% log)))

#------------------------------------------------------------------------------------------------#
## 4/6 num of breakpoints per chromosome arm
grid.arrange(give_joint_histogram(list(distrib_bpchrarm[['org']]$`mean(ct1_num)`,
                          distrib_bpchrarm[['pcawg']]$`mean(ct1_num)`,
                          distrib_bpchrarm[['tcga']]$`mean(ct1_num)`,
                          distrib_bpchrarm[['BriTROC']]$`mean(ct1_num)`), no_colour=FALSE)+ggtitle('Raw'),
give_joint_histogram(list(distrib_bpchrarm[['org']]$`mean(ct1_num)` %>% log,
                          distrib_bpchrarm[['pcawg']]$`mean(ct1_num)` %>% log,
                          distrib_bpchrarm[['tcga']]$`mean(ct1_num)` %>% log,
                          distrib_bpchrarm[['BriTROC']]$`mean(ct1_num)` %>% log), no_colour=FALSE)+ggtitle('Log transform'), ncol=2)

## Same distribution of num of breakpoints per chromosome arm
t.test(distrib_bpchrarm[['org']]$`mean(ct1_num)` %>% log,
       c(distrib_bpchrarm[['pcawg']]$`mean(ct1_num)` %>% log,
         distrib_bpchrarm[['tcga']]$`mean(ct1_num)` %>% log,
         distrib_bpchrarm[['BriTROC']]$`mean(ct1_num)` %>% log))


#------------------------------------------------------------------------------------------------#
## 5/6 num of changepoints
grid.arrange(give_joint_histogram(list(distrib_changepoint[['org']]$`mean(ct1_num)`,
                          distrib_changepoint[['pcawg']]$`mean(ct1_num)`,
                          distrib_changepoint[['tcga']]$`mean(ct1_num)`,
                          distrib_changepoint[['BriTROC']]$`mean(ct1_num)`), no_colour=FALSE)+ggtitle('Raw'),
give_joint_histogram(list(distrib_changepoint[['org']]$`mean(ct1_num)` %>% log,
                          distrib_changepoint[['pcawg']]$`mean(ct1_num)` %>% log,
                          distrib_changepoint[['tcga']]$`mean(ct1_num)` %>% log,
                          distrib_changepoint[['BriTROC']]$`mean(ct1_num)` %>% log), no_colour=FALSE)+ggtitle('Log transform'), ncol=2)

## Same distribution of num of changepoints
t.test(distrib_changepoint[['org']]$`mean(ct1_num)` %>% log,
       c(distrib_changepoint[['pcawg']]$`mean(ct1_num)` %>% log,
         distrib_changepoint[['tcga']]$`mean(ct1_num)` %>% log,
         distrib_changepoint[['BriTROC']]$`mean(ct1_num)` %>% log))

#------------------------------------------------------------------------------------------------#
## 6/6 copy number
grid.arrange(give_joint_histogram(list(distrib_copynumber[['org']]$`mean(ct1_num)`,
                          distrib_copynumber[['pcawg']]$`mean(ct1_num)`,
                          distrib_copynumber[['tcga']]$`mean(ct1_num)`,
                          distrib_copynumber[['BriTROC']]$`mean(ct1_num)`), no_colour=FALSE)+ggtitle('Raw'),
give_joint_histogram(list(distrib_copynumber[['org']]$`mean(ct1_num)` %>% log,
                          distrib_copynumber[['pcawg']]$`mean(ct1_num)` %>% log,
                          distrib_copynumber[['tcga']]$`mean(ct1_num)` %>% log,
                          distrib_copynumber[['BriTROC']]$`mean(ct1_num)` %>% log), no_colour=FALSE)+ggtitle('Log transform'), ncol=2)

## Same distribution of copy number of segments
t.test(distrib_copynumber[['org']]$`mean(ct1_num)` %>% log,
       c(distrib_copynumber[['pcawg']]$`mean(ct1_num)` %>% log,
         distrib_copynumber[['tcga']]$`mean(ct1_num)` %>% log,
         distrib_copynumber[['BriTROC']]$`mean(ct1_num)` %>% log))

```

**Explanation**: The distribution of sample-averaged values of features are the sample between organoids and the cohorts of primary tissue samples for the number of breakpoints per 10MB (Welch Two Sample t-test on log-transformed data, p-value = 0.6059), segment size (Welch Two Sample t-test on log-transformed data, p-value = 0.4501
), oscillating copy number (Welch Two Sample t-test on log-transformed data, p-value = 0.7191), number of breakpoints per chromosome arm  (Welch Two Sample t-test on log-transformed data, p-value = 0.6007), number of changepoints (Welch Two Sample t-test on log-transformed data, p-value = 0.8472), and the copy number of the segments (Welch Two Sample t-test on log-transformed data, p-value = 0.7275).

## Number of segments; Poisson and NegBin GLM
TL;DR with a negative binomial model, which is much more appropriate in this setting than a Poisson, there is no difference in the distributions of organoids and non-organodis when it comes to **number of segments**.

```{r, modelling_number_of_segments, echo=FALSE}

## poisson test
number_of_segments = list(organoids= table(organoids_CN_features[[1]]$ID),
                            #organoids_CN_features[[1]] %>% group_by(ID) %>%
                           #group_map( ~ nrow(.x)) %>% unlist,
                          BriTROC=table(BriTROC_CN_features[[1]]$ID),
                            #BriTROC_CN_features[[1]] %>% group_by(ID) %>%
                            #group_map( ~ nrow(.x)) %>% unlist,
                           # BriTROC2=table(BriTROC2_CN_features$sample),
                            #BriTROC2_CN_features %>% group_by(sample) %>% group_map( ~ nrow(.x)) %>% unlist,
                          pcawg=table(pcawg_CN_features[[1]]$ID),
                            #pcawg_CN_features[[1]] %>% group_by(ID) %>%
                            #group_map( ~ nrow(.x)) %>% unlist,
                          tcga=table(tcga_CN_features[[1]]$ID))
                            #tcga_CN_features[[1]] %>% group_by(ID) %>%
                            #group_map( ~ nrow(.x)) %>% unlist)

# poisson.test()

glm_poisson_length = cbind.data.frame(length=unlist(number_of_segments), names=rep(names(number_of_segments), sapply(number_of_segments, length)))
glm_poisson_length[,'bool'] = as.numeric(glm_poisson_length$names == 'organoids')

reduced = glm(formula = length ~ 1, family = "poisson", data = glm_poisson_length)
full = glm(formula = length ~ bool, family = "poisson", data = glm_poisson_length)

res_LRT = anova(reduced, full, test = "LRT")
res_LRT

## Negative binomial
reduced_nb = glm.nb(formula = length ~ 1, data = glm_poisson_length)
full_nb = glm.nb(formula = length ~ bool, data = glm_poisson_length)
res_LRT_nb = anova(reduced_nb, full_nb, test = "LRT")
res_LRT_nb

# but in fact when using negative binomial this is no longer the case
```

```{r, number_of_segments_table}
sapply(list(glm_poisson_length[glm_poisson_length$names == 'organoids','length']), function(i) c(mean(i), sd(i)))
sapply(list(glm_poisson_length[glm_poisson_length$names != 'organoids','length']), function(i) c(mean(i), sd(i)))
```

Unfortunately the scaling factor has to do with the width of the bins in the histogram.
```{r, plotting_poisson_fit, echo=FALSE, dependson=c('modelling_number_of_segments')}
# list_all_nsegments = list(organoids=organoids_CN_features[[1]] %>% group_by(ID) %>%
#                            group_map( ~ nrow(.x)) %>% unlist,
#                           BriTROC=BriTROC_CN_features[[1]] %>% group_by(ID) %>%
#                             group_map( ~ nrow(.x)) %>% unlist,
#                           pcawg=pcawg_CN_features[[1]] %>% group_by(ID) %>%
#                             group_map( ~ nrow(.x)) %>% unlist,
#                           tcga=tcga_CN_features[[1]] %>% group_by(ID) %>%
#                             group_map( ~ nrow(.x)) %>% unlist)

## Plot together with values
sequence_dpois = seq(min(unlist(number_of_segments)), max(unlist(number_of_segments)), by = 2)
# plot(scaling_factor*dpois(x = sequence_dpois, lambda = reduced$fitted.values[1]))

data_poisson = do.call('rbind.data.frame', lapply(c('BriTROC', 'organoids', 'pcawg', 'tcga'), function(i){
  scaling_factor = length(number_of_segments[[i]])
  extra_scaling_factor = (max(number_of_segments[[i]])-min(number_of_segments[[i]]))/30 ## we would need to know the number of pixels per unit
  extra_scaling_factor = 9
  cbind.data.frame(value=sequence_dpois,
                                    count=scaling_factor*extra_scaling_factor*dpois(x = sequence_dpois, lambda = reduced$fitted.values[1]), L1=i)}))
        
data_NB = do.call('rbind.data.frame', lapply(c('BriTROC', 'organoids', 'pcawg', 'tcga'), function(i){
  scaling_factor = length(number_of_segments[[i]])
  extra_scaling_factor = (max(number_of_segments[[i]])-min(number_of_segments[[i]]))/30 ## we would need to know the number of pixels per unit
  extra_scaling_factor = 50
  cbind.data.frame(value=sequence_dpois,
                   count=scaling_factor*extra_scaling_factor*dnbinom(x = sequence_dpois, mu = unique(fitted(reduced_nb)), size = reduced_nb$theta, log = FALSE),
                   L1=i)}))


give_joint_histogram(number_of_segments, bins=30)+ggtitle('Number of segments')+
  geom_line(data = data_poisson, aes(x=value, y=count))+
  geom_line(data = data_NB, aes(x=value, y=count), col='red')+
  ggtitle('Observed number of segments and Poisson (black)\nand Negative Binomial (red) model')+
  theme(legend.position = "bottom")

```


```{r, comparison_numsegments_step, fig.height=3, echo=FALSE}
ggplot(reshape2::melt(list(unlist(number_of_segments[-1]), number_of_segments[1])),
       aes(x=value, fill=L1, group=L1, col=L1), alpha=0.2)+ stat_bin(geom="step", bins = 30)+
  facet_wrap(.~L1, nrow=1, scales='free_y')+ggtitle('Comparison on non-organoids (left) and organoids (right)')
```


## Ploidy
To get the ploidy, I just have to compute the weighted average of the copy number segments (this is computed from the absolute copy number profiles objects, since they specify, for each segment, its length and its ploidy).

Use getSegTable to get the segments from this Biobase file

*Needs to be ammended*: it has to also count areas of the genome for which we don't have segments! i.e. we need to know the effective genome size

```{r, get_segtables, echo=FALSE}
segtables_BriTROC_absolute_copynumber = lapply(sampleNames(BriTROC_absolute_copynumber), function(samplename) getSegTable(BriTROC_absolute_copynumber[,samplename]))
names(segtables_BriTROC_absolute_copynumber) = sampleNames(BriTROC_absolute_copynumber)
segtables_organoids_absolute_copynumber = lapply(sampleNames(organoids_absolute_copynumber), function(samplename) getSegTable(organoids_absolute_copynumber[,samplename]))
names(segtables_organoids_absolute_copynumber) = sampleNames(organoids_absolute_copynumber)
# names(segtables_organoids_absolute_copynumber) = names_orgs$`new name`[match(gsub("org", "", names(segtables_organoids_absolute_copynumber)), names_orgs$`old name`)]

TCGA_absolute_copynumber = readRDS("data/combined.ascat.segments.filt.rds")

## we only want the ovarian ones
## select the TCGA samples which are in the subset in which we are interested (the ones that passed QC and that are only OV)
TCGA_absolute_copynumber = TCGA_absolute_copynumber[TCGA_absolute_copynumber$sample %in% rownames(natgen$UpdatedExposures),]
segtables_TCGA_absolute_copynumber = lapply(as.character(sort(unique(TCGA_absolute_copynumber$sample))), function(samplename) TCGA_absolute_copynumber[TCGA_absolute_copynumber$sample == samplename,])
segtables_TCGA_absolute_copynumber = lapply(segtables_TCGA_absolute_copynumber, function(i) i[,1:(ncol(i)-1)]) ## removing sample name
names(segtables_TCGA_absolute_copynumber) = as.character(sort(unique(TCGA_absolute_copynumber$sample)))
```

```{r, get_segtables2}
## we only want the ovarian ones
ICGC_absolute_copynumber_AU = readRDS("data/CN_Calls_ABSOLUTE_PCAWG/OV-AU.segments.raw.rds")
ICGC_absolute_copynumber_US = readRDS("data/CN_Calls_ABSOLUTE_PCAWG/OV-US.segments.raw.rds")
ICGC_absolute_copynumber_AU = ICGC_absolute_copynumber_AU[,c('sample', 'chr', 'startpos', 'endpos', 'segVal')]
ICGC_absolute_copynumber_US = ICGC_absolute_copynumber_US[,c('sample', 'chr', 'startpos', 'endpos', 'segVal')]

segtables_ICGC_absolute_copynumber_AU = lapply(sort(unique(ICGC_absolute_copynumber_AU$sample)),
                                            function(samplename)
                                              ICGC_absolute_copynumber_AU[ICGC_absolute_copynumber_AU$sample == samplename,])
segtables_ICGC_absolute_copynumber_AU = lapply(segtables_ICGC_absolute_copynumber_AU, function(i) { colnames(i)[colnames(i) == "chr"] = "chromosome";
colnames(i)[colnames(i) == "endpos"] = "end";
return(i) } )
names(segtables_ICGC_absolute_copynumber_AU) = unique(ICGC_absolute_copynumber_AU$sample)

segtables_ICGC_absolute_copynumber_US = lapply(sort(unique(ICGC_absolute_copynumber_US$sample)),
                                            function(samplename) ICGC_absolute_copynumber_US[ICGC_absolute_copynumber_US$sample == samplename,])
segtables_ICGC_absolute_copynumber_US = lapply(segtables_ICGC_absolute_copynumber_US, function(i) { colnames(i)[colnames(i) == "chr"] = "chromosome";
colnames(i)[colnames(i) == "endpos"] = "end";
return(i) } )
names(segtables_ICGC_absolute_copynumber_US) = unique(ICGC_absolute_copynumber_US$sample)

## for ICGC, remove the samples row and put it in the rows
segtables_ICGC_absolute_copynumber_US = lapply(segtables_ICGC_absolute_copynumber_US, function(i){
  rownames(i) = i$samples
  i = i[,-1]
  i})
segtables_ICGC_absolute_copynumber_AU = lapply(segtables_ICGC_absolute_copynumber_AU, function(i){
  rownames(i) = i$samples
  i = i[,-1]
  i})
```


```{r, get_segtables3, echo=FALSE, warning=FALSE}
### Make numeric
segtables_BriTROC_absolute_copynumber <- lapply(segtables_BriTROC_absolute_copynumber, function(segtab) apply(segtab, 2, as.numeric)) ## convert to numeric matrices
segtables_organoids_absolute_copynumber <- lapply(segtables_organoids_absolute_copynumber, function(segtab) apply(segtab, 2, as.numeric)) ## convert to numeric matrices
segtables_ICGC_absolute_copynumber_AU <- lapply(segtables_ICGC_absolute_copynumber_AU, function(segtab) apply(segtab, 2, as.numeric)) ## convert to numeric matrices
segtables_ICGC_absolute_copynumber_US <- lapply(segtables_ICGC_absolute_copynumber_US, function(segtab) apply(segtab, 2, as.numeric)) ## convert to numeric matrices
segtables_TCGA_absolute_copynumber <- lapply(segtables_TCGA_absolute_copynumber, function(segtab) apply(segtab, 2, as.numeric)) ## convert to numeric matrices

### remove sex chromosomes from any downstream analysis
segtables_TCGA_absolute_copynumber = lapply(segtables_TCGA_absolute_copynumber, function(i) i[!(is.na(i[,1])),])
segtables_ICGC_absolute_copynumber_US = lapply(segtables_ICGC_absolute_copynumber_US, function(i) i[!(is.na(i[,1])),])
segtables_ICGC_absolute_copynumber_AU = lapply(segtables_ICGC_absolute_copynumber_AU, function(i) i[!(is.na(i[,1])),])

## check that there are no sex chromosomes
cat('Check that there are no sex chromosomes included anywhere')
sapply(list(segtables_TCGA_absolute_copynumber, segtables_ICGC_absolute_copynumber_US, segtables_ICGC_absolute_copynumber_AU,
            segtables_organoids_absolute_copynumber, segtables_BriTROC_absolute_copynumber),
       function(list_segments) all(sapply(list_segments, function(i) sum(apply(i, 2, is.na))) == 0) )

```


```{r, getploidy, dependson=c('get_segtables', 'get_segtables2'), echo=FALSE, eval=TRUE}
GRanges_chroms = as(droplevels(data.frame(chrom=gsub("chr", "", chrlen$V1), start=1, end=chrlen$V2)[!chrlen$V1 %in% c('chrX', 'chrY'),]),
                    "GRanges")
rename_cols <- function(df){
  colnames(df)[colnames(df) == 'startpos'] = 'start'
  colnames(df)[colnames(df) == 'endpos'] = 'end'
  return(df)
}
diploidifNA <- function(x){
  ifelse(is.na(x), 2, x)
}
weighted_ploidy <- function(ploidy, widths){
  isna = is.na(ploidy) | is.na(widths)
  ploidy = ploidy[!isna]
  widths = widths[!isna]
  sum( ploidy * widths/sum(widths) )
}
## not applicable here. it looks like all segments were included anyway
give_ploidy = function(segtab){
  ## new version
  ## I need to find the overlaps with the whole genome, and compute the weighted ploidy with also normal segments
  full_GR <- c(GRanges_chroms, as(rename_cols(data.frame(segtab)), "GRanges"))
  granges <- GenomicRanges::disjoin(full_GR, with.revmap=TRUE, ignore.strand=TRUE)
  ploidies_all_segs = sapply(granges$revmap, function(idxs){
    ## if it's an overlap, get the ploidy of the second indexed segment (i.e. the CN segment). otherwise, it's diploid
    if(length(idxs) == 2){
      full_GR[idxs[[2]]]$segVal
    }else if(length(idxs) == 1){
      2
    }
   })
  ploidies_all_segs[sapply(ploidies_all_segs, length) == 0] = NA
  return(weighted_ploidy(unlist(ploidies_all_segs), width(granges)))
}
give_ploidy = function(segtab){
  ## old version
  .lengths = apply(segtab, 1, function(rw) rw[3]-rw[2])
  sum(segtab[,4]*.lengths/sum(.lengths))
}

ploidy_ICGC_US = sapply(segtables_ICGC_absolute_copynumber_US, give_ploidy)
ploidy_ICGC_AU = sapply(segtables_ICGC_absolute_copynumber_AU, give_ploidy)
ploidy_TCGA = sapply(segtables_TCGA_absolute_copynumber, give_ploidy)
ploidy_BriTROC = sapply(segtables_BriTROC_absolute_copynumber, give_ploidy)
ploidy_organoids = sapply(segtables_organoids_absolute_copynumber, give_ploidy)
```

```{r, ploidy_debug, eval=TRUE, include=FALSE}
give_ploidy_previous = function(segtab){
  ## old version
  .lengths = apply(segtab, 1, function(rw) rw[3]-rw[2])
  sum(segtab[,4]*.lengths/sum(.lengths))
}
ploidy_ICGC_US_previous = sapply(segtables_ICGC_absolute_copynumber_US, give_ploidy_previous)
ploidy_ICGC_AU_previous = sapply(segtables_ICGC_absolute_copynumber_AU, give_ploidy_previous)
ploidy_TCGA_previous = sapply(segtables_TCGA_absolute_copynumber, give_ploidy_previous)
ploidy_BriTROC_previous = sapply(segtables_BriTROC_absolute_copynumber, give_ploidy_previous)
ploidy_organoids_previous = sapply(segtables_organoids_absolute_copynumber, give_ploidy_previous)

# ploidy_ICGC_US = sapply(segtables_ICGC_absolute_copynumber_US[1:2], give_ploidy)
# ploidy_ICGC_AU = sapply(segtables_ICGC_absolute_copynumber_AU[1:2], give_ploidy)
# ploidy_TCGA = sapply(segtables_TCGA_absolute_copynumber[1:2], give_ploidy)
# ploidy_BriTROC = sapply(segtables_BriTROC_absolute_copynumber[1:2], give_ploidy)
# ploidy_organoids = sapply(segtables_organoids_absolute_copynumber[1:2], give_ploidy)
```


In the previous computation of the sample ploidy (ploidy\_ICGC\_US\_previous, etc.) I had not included normal segments. Now I do but actually the result is very similar. (Note slghtly under- and over-estimated values at the right and left of ploidy=2).
```{r, ploidy_debug_2}
plot(log(c(ploidy_ICGC_US_previous, ploidy_ICGC_AU_previous, ploidy_TCGA_previous,
           ploidy_BriTROC_previous, ploidy_organoids_previous)),
     log(c(ploidy_ICGC_US, ploidy_ICGC_AU, ploidy_TCGA, ploidy_BriTROC, ploidy_organoids)),
     ylab='log ploidy of samples with current mean ploidy calculation',
     xlab='log ploidy of samples with previous mean ploidy calculation')
abline(coef=c(0,1), lty='dashed')
abline(v=log(2), lty='dashed')
```

Ploidy is not normally distributed and it's right-skewed. Moreover, the distribution is bimodal: I guess there are genomes in which there is a clear amplification and genomes which are more or less normal, so centered around 2.
```{r, ploidy_plots, dependson=c('getploidy'), echo=FALSE, eval=TRUE}
grid.arrange(give_joint_histogram(list(organoids=ploidy_organoids, ICGC_US=ploidy_ICGC_US, ICGC_AU=ploidy_ICGC_AU, TCGA_OV=ploidy_TCGA, BriTROC=ploidy_BriTROC))+
  ggtitle('Ploidy')+theme(legend.position = "bottom")+geom_vline(xintercept = 2)+geom_vline(xintercept = 1),
  give_joint_histogram(lapply(list(organoids=ploidy_organoids, ICGC_US=ploidy_ICGC_US, ICGC_AU=ploidy_ICGC_AU, TCGA_OV=ploidy_TCGA, BriTROC=ploidy_BriTROC), log))+theme(legend.position = "bottom")+geom_vline(xintercept = log(2))+ggtitle('Logged ploidy')+geom_vline(xintercept = log(1)), ncol=2)

# - The ploidy in the BriTROC cohort is `r {mean(ploidy_BriTROC)}` $\pm$ `r {mean(ploidy_BriTROC)}` (sd).
# - The ploidy in the TCGA cohort (AU) is `r {mean(ploidy_TCGA)}` $\pm$ `r {mean(ploidy_TCGA)}` (sd).
# - The ploidy in the ICGC cohort (AU) is `r {mean(ploidy_ICGC_AU)}` $\pm$ `r {mean(ploidy_ICGC_AU)}` (sd).
# - The ploidy in the ICGC cohort (US) is `r {mean(ploidy_ICGC_US)}` $\pm$ `r {mean(ploidy_ICGC_US)}` (sd).
# - The ploidy in the whole ICGC cohort is `r {mean(c(ploidy_ICGC_US, ploidy_ICGC_AU))}` $\pm$ `r {mean(c(ploidy_ICGC_US, ploidy_ICGC_AU))}` (sd).
# - The ploidy in the **organoid** cohort is `r {mean(ploidy_organoids)}` $\pm$ `r {mean(ploidy_organoids)}` (sd).

```



I am also using a robust linear regression, but I don't think this is suitable either.


```{r, test_ploidy, eval=TRUE}
t.test(log(ploidy_organoids), log(ploidy_BriTROC))
MASS::rlm(ploidy~group,
         data=cbind.data.frame(ploidy=c(ploidy_organoids, ploidy_BriTROC), group=c(rep(1,length(ploidy_organoids)), rep(2, length(ploidy_BriTROC)))))
```


## Segments across the genome
```{r, chromosomes_lengths}
## Segments across the genome
# (sapply(chrlen$V1, function(i) gsub("chr", "", i)))
sorted_chroms = chrlen$V1[order(as.numeric((gsub("chr", "", chrlen$V1))))]
chrom_lenths = chrlen[match(sorted_chroms, chrlen$V1),]
```

## Ploidy
```{r, ploidies_boxplot, echo=FALSE, fig.height=3, fig.width=3}
ploidies = rbind.data.frame(cbind.data.frame(cohort='pcawg',
                                             ploidy=c(ploidy_ICGC_US,
                                                      ploidy_ICGC_AU)),
    cbind.data.frame(cohort='tcga',  ploidy=ploidy_TCGA),
    cbind.data.frame(cohort='BriTROC',  ploidy=ploidy_BriTROC),
    cbind.data.frame(cohort='organoids', ploidy=ploidy_organoids))
ploidies[,'organoids_bool'] = c('Clinical', 'Organoids')[1+as.numeric(grepl('organoids', ploidies$cohort))]


ggplot(ploidies, aes(x=organoids_bool, y=ploidy))+geom_boxplot()

```


## Ranking for the number of copy number events and ploidy
```{r, rank_plots, fig.width=10, echo=FALSE}
#  hierarchical clustering or ranking for the number of copy number events

# BriTROC2 (now deleted) was the same as BriTROC
# all(num_segs_rank[num_segs_rank$L1 == 'BriTROC','value'] == num_segs_rank[num_segs_rank$L1 == 'BriTROC2','value'])

plot_rank(melt(number_of_segments), nudge_scalar=1)+ggtitle("Number of segments")
plot_rank(cbind.data.frame(value=as.numeric(ploidies$ploidy), L1=gsub("ploidy_", "", as.character(ploidies$cohort)),
                           Var1=rownames(ploidies)), nudge_scalar=0.2)+ggtitle("Ploidy")

pdf("figures/rank_segments_2.pdf", width = 14, height = 6)
plot_rank(melt(number_of_segments))+ggtitle("Number of segments")
dev.off()
pdf("figures/rank_ploidy_2.pdf", width = 14, height = 6)
plot_rank(cbind.data.frame(value=as.numeric(ploidies$ploidy), L1=gsub("ploidy_", "", as.character(ploidies$cohort)),
                           Var1=rownames(ploidies)), nudge_scalar=0.02)+ggtitle("Ploidy")
dev.off()

saveRDS(plot_rank(melt(number_of_segments)), "robjects/rank_nsegments.RDS")
saveRDS(plot_rank(cbind.data.frame(value=as.numeric(ploidies$ploidy), L1=gsub("ploidy_", "", as.character(ploidies$cohort)),
                           Var1=rownames(ploidies)), nudge_scalar=0.02), "robjects/rank_ploidy.RDS")

saveRDS(melt(number_of_segments), "robjects/rank_nsegments_df.RDS")
saveRDS(cbind.data.frame(value=as.numeric(ploidies$ploidy), L1=gsub("ploidy_", "", as.character(ploidies$cohort)),
                           Var1=rownames(ploidies)), "robjects/rank_ploidy_df.RDS")

```

```{r, xxxx_ploidies}
saveRDS("robjects/cb.RDS", object = cbind.data.frame(value=as.numeric(ploidies$ploidy), L1=gsub("ploidy_", "", as.character(ploidies$cohort)),
                           Var1=rownames(ploidies)))
head(melt(number_of_segments))
head(cbind.data.frame(value=as.numeric(ploidies$ploidy), L1=gsub("ploidy_", "", as.character(ploidies$cohort)),
                           Var1=rownames(ploidies)))
```

```{r, across_genome_plot, fig.height=8, message=FALSE, echo=FALSE}
bps = lapply(list(
  segtables_ICGC_absolute_copynumber_US,
            segtables_ICGC_absolute_copynumber_AU,
            segtables_TCGA_absolute_copynumber,
            segtables_BriTROC_absolute_copynumber,
            segtables_organoids_absolute_copynumber
            ), wrapper_get_bp)

names(bps) = c('ICGC_US', 'ICGC_AU', 'TCGA', 'BriTROC', 'organoids')
df_plotting = cbind(melt(bps), x=as.vector(sapply(bps, function(bpsit) 1:nrow(bpsit))))
levels(df_plotting$x) = sort(unique(df_plotting$x))
ggplot(df_plotting, aes(y=value, x=x))+geom_line(aes(group=L1))+facet_wrap(.~L1, ncol=1, scales = "free_y")

```

```{r, print_organoids_absolute_copynumber}
head(organoids_absolute_copynumber)
```

<!-- ## Comparing amplified/deleted genes between organoids and TCGA -->

```{r, annotate_genes, eval=FALSE}

gtf.file <- file.path("../RNASeq_and_CN/20191218_ViasM_BJ_orgaBrs/Data/Homo_sapiens.GRCh37.87.gtf.gz")
sqlite_file <- '../RNASeq_and_CN/20191218_ViasM_BJ_orgaBrs/Data/Homo_sapiens.GRCh37.87.sqlite'
sqlite_path <- file.path(sqlite_file)

if(!file.exists(sqlite_path)) {
  ## generate the SQLite database file
  ensembldb::ensDbFromGtf(gtf=gtf.file, path=ref_dir, outfile=sqlite_file)
}
EnsDb.Hsapiens.v87 <- ensembldb::EnsDb(sqlite_file)

# Genes, used to annotated the TPM matrix to send to Maria
ag <- ensembldb::genes(EnsDb.Hsapiens.v87,  return.type="DataFrame") 
geneInfo = cbind.data.frame(chrom=ag$seq_name, start=ag$gene_seq_start, end=ag$gene_seq_end, geneid=ag$entrezid, genename=ag$symbol)
```

```{r, compare_amplification, dependson=c('annotate_genes'), eval=FALSE}
# data("geneInfo")
gr_BriTROC <- lapply(segtables_BriTROC_absolute_copynumber, function(i) as(data.frame(i), "GRanges"))
gr_genes_of_interest = as(data.frame(geneInfo[!(geneInfo$chrom %in% c('X', 'Y')), c('chrom', 'start', 'end', 'genename', 'geneid' )]), "GRanges")

# gr_genes_of_interest = as(data.frame(rbind(c(1, 830001, 860001),
#                           geneInfo[sample(1:nrow(geneInfo), 2000),c('chrom', 'start', 'end' )])), "GRanges")

give_ploidy_gene <- function(gene_idx, sample){
  disjoint_segments <- GenomicRanges::disjoin(c(gr_genes_of_interest[gene_idx,], sample), with.revmap=TRUE, ignore.strand=TRUE)
  # GenomicRanges::disjoin(c(gr_genes_of_interest[1,], gr_BriTROC$IM_100[1,]), with.revmap=TRUE, ignore.strand=TRUE)
  # GenomicRanges::disjoin(c(gr_BriTROC$IM_100[1,], gr_genes_of_interest[1,]), with.revmap=FALSE, ignore.strand=TRUE)
  # GenomicRanges::disjoin(c(gr_genes_of_interest[1,], gr_BriTROC$IM_100[1,]), with.revmap=FALSE, ignore.strand=TRUE)
  
  # disjoint_segments = GenomicRanges::reduce(c(gr_genes_of_interest[1,], gr_BriTROC$IM_100[1,]), with.revmap=TRUE, ignore.strand=TRUE)
  # disjoint_segments_b = GenomicRanges::reduce(c(gr_BriTROC$IM_100[1,], gr_genes_of_interest[1,]), with.revmap=TRUE, ignore.strand=TRUE)
  revmap <- mcols(disjoint_segments)$revmap
  r_scores <- extractList(mcols(c(gr_genes_of_interest[gene_idx,], sample))$segVal, revmap)

  return(weighted_ploidy(diploidifNA(sapply(1:length(r_scores), function(idx) if(1 %in% revmap[[idx]]){r_scores[[idx]][2]}else{r_scores[[idx]][1]})[sapply(revmap, function(i) any(1 %in% i))]),
                  width(disjoint_segments)[sapply(revmap, function(i) 1 %in% i)]))
}

all_ranges_cohort = rep(1:5, c(length(gr_BriTROC), length(segtables_ICGC_absolute_copynumber_AU),
                              length(segtables_ICGC_absolute_copynumber_US),
                              length(segtables_TCGA_absolute_copynumber),
                              length(segtables_organoids_absolute_copynumber)))
all_ranges_cohort = c('BriTROC', 'ICGC AU', 'ICGC US', 'TCGA', 'Organoids')[all_ranges_cohort]
all_ranges = c(gr_BriTROC,
               lapply(segtables_ICGC_absolute_copynumber_AU, function(i) as(data.frame(rename_cols(i)), "GRanges")),
               lapply(segtables_ICGC_absolute_copynumber_US, function(i) as(data.frame(rename_cols(i)), "GRanges")),
               lapply(segtables_TCGA_absolute_copynumber, function(i) as(data.frame(rename_cols(i)), "GRanges")),
               lapply(segtables_organoids_absolute_copynumber, function(i) as(data.frame(rename_cols(i)), "GRanges")))
subsample_samples = sample(1:length(all_ranges), 10)
subset_genes = c('MYC', 'CCNE1', 'PIK3CA', 'TERT', 'KRAS', 'PTEN', 'RB1', 'AKT1',
                 'AKT2', 'PARP1', 'PARP2', 'ATM', 'ATR', 'WEE1', 'TOP1', 'TUBB1', 'ZWINT', 'ERBB2')
# subsample_samples = sort(subsample_samples)
subsample_samples = 1:length(all_ranges)
# all_ploidies = outer(X = 1:length(gr_genes_of_interest),
# all_ploidies = outer(X =  which(geneInfo$genename %in% subset_genes),
#                      Y = subsample_samples, Vectorize(function(x, y) give_ploidy_gene(x,all_ranges[[y]])))
# all_ploidies = t(all_ploidies)
# rownames(all_ploidies) = names(all_ranges)[subsample_samples]
# ann_row = data.frame(cohort=all_ranges_cohort[subsample_samples], row.names = names(all_ranges)[subsample_samples])
# pheatmap(all_ploidies, annotation_row = ann_row, cluster_rows = FALSE)

```

```{r, compare_amplification_generalised, echo=FALSE, eval=FALSE, dependson=c('compare_amplification')}
## scaling up to multiple genes (I have a problem with runtime)
give_ploidy_gene_scaling <- function(sample, subset_genes_arg){
  
  # GRanges object with a row for each entry in subset_genes (sorted)
  gr_genes_of_interest_subset = as(geneInfo[which(geneInfo$genename %in% subset_genes_arg),], 'GRanges')
  idx_genes <- match(subset_genes_arg, gr_genes_of_interest_subset$genename)
  gr_genes_of_interest_subset = gr_genes_of_interest_subset[idx_genes[!is.na(idx_genes)],]
  subset_genes_arg <- subset_genes_arg[!is.na(idx_genes)]
  all(gr_genes_of_interest_subset$genename == subset_genes_arg)
  
  ## Both the genes and the samples, so that they can be split
  full_GRanges = c(gr_genes_of_interest_subset, sample)
  disjoint_segments <- GenomicRanges::disjoin(full_GRanges,
                       with.revmap=TRUE, ignore.strand=TRUE)
  ## disjoint_segments contains a long GRanges object with the overlaps between any two intervals (genes or CN segments)
  
  ## revmap contains the map to the genes and CN segments, for each of the disjoint intervals
  
  revmap <- mcols(disjoint_segments)$revmap
  length(unique(unlist(revmap)))
  length(gr_genes_of_interest_subset)+length(sample)
  
  ## keep only the intervals that refer to overlaps with genes, and not only with samples
  keep_bool = sapply(revmap, function(revmap_idx) any(1:length(gr_genes_of_interest_subset) %in% revmap_idx) )
  
  ## revmap_short keeps the map, but only for the segments of interest (i.e. overlap with genes)
  revmap_short = revmap[keep_bool,]
  disjoint_segments_short = disjoint_segments[keep_bool,]
  ## Note that here, in revmap_short, the rows are unsorted, and multiple rows might correspond to the same gene
  
  ## computing the widths of the disjoint segments of interest
  widths_disjoint_short = width(disjoint_segments)[keep_bool]
  
  ## for each of the rows in revmap_short, get the segVal (unrounded CN). The first element of each row is going to be NA, as
  ## the first elements in revmap_short correspond to the genes, and the second to the CN segments
  r_scores = extractList(mcols(full_GRanges)$segVal, sapply(revmap_short, function(i) i[length(i)] ))

  ## for each of the genes of interest, which are indexed by gene_idx, and which are ordered as in subset_genes,
  ## we get the rows in revmap_short that contain them (which are stored in the index vector genes_idx).
  ## It might be that there are several rows that contain the same gene (in which case we have to compute the weighted sum
  ## of the CN values). For each of the overlaps, find the ploidy and its width
  ## In the case that the overlap doesn't have a CN, because it's outside of any segment, make this interval diploid, CN=2
  weights = sapply(1:length(gr_genes_of_interest_subset), function(gene_idx){
    genes_idx_vec = sapply(revmap_short, function(i) which(gene_idx %in% i))
    genes_idx = which(sapply(genes_idx_vec, length) > 0)
    ploidies_short = diploidifNA(sapply(1:length(genes_idx), function(j){
      ## we get the first(and only) element in the list by [[1]] and we get the second index [2],
      ## which is the only that has a CN value (the first one corresponds to the gene)
      r_scores[genes_idx,][j,][[1]]
    }))
    return(weighted_ploidy(ploidies_short,
                    widths_disjoint_short[genes_idx]))
  })
  names(weights) = subset_genes_arg
  return(weights)
}

subsample_samples = all_ranges
all_ploidies_2 = mclapply(subsample_samples, give_ploidy_gene_scaling, subset_genes_arg=subset_genes)
all_ploidies_2_df_original = data.frame(do.call('rbind', all_ploidies_2))
all_ploidies_2_df = all_ploidies_2_df_original
image(do.call('rbind', all_ploidies_2))

## there are some outliers, which I remove

## some ploidies are negative (??)
sum(all_ploidies_2_df < 0)
all_ploidies_2_df[all_ploidies_2_df < 0] = NA
sum(na.omit(all_ploidies_2_df > 15))
all_ploidies_2_df[all_ploidies_2_df > 15] = NA
## because I am doing the log, remove zeros
# sum(na.omit(all_ploidies_2_df == 0))
# all_ploidies_2_df[all_ploidies_2_df == 0] = NA

ann_row = data.frame(cohort=all_ranges_cohort, row.names = names(all_ranges))
# pheatmap(log(all_ploidies_2_df), annotation_row = ann_row, cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, scale = "none")

pheatmap((all_ploidies_2_df), annotation_row = ann_row, cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, scale = "row")

paletteLength <- 50
myColor <- colorRampPalette(c("yellow", "white", "blue"))(paletteLength)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(0, 2, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(all_ploidies_2_df, na.rm = TRUE)/paletteLength, max(all_ploidies_2_df, na.rm = TRUE), length.out=floor(paletteLength/2)))

pheatmap((all_ploidies_2_df), annotation_row = ann_row, cluster_rows = TRUE, cluster_cols = FALSE, show_rownames = FALSE, scale = "none", color=myColor, breaks=myBreaks)

pheatmap((all_ploidies_2_df), annotation_row = ann_row, cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, scale = "none", color=myColor, breaks=myBreaks)

```



```{r, heatmap_ampldel_organoids, dependson=c('compare_amplification_generalised'), eval=FALSE}
pheatmap((all_ploidies_2_df[ann_row == 'Organoids',]), cluster_rows = FALSE, cluster_cols = FALSE,
         show_rownames = TRUE, scale = "none", color=myColor, breaks=myBreaks)

```

```{r, heatmap_ampldel_organoids_v2, eval=FALSE, dependson=c('compare_amplification_generalised')}
subsetgenes_2 <- c('ZWINT', 'CASC8', 'ERBB2', 'FAM84B', 'IKZF3', 'KIAA0196', 'LINC00964', 'MIEN1',
                   'MIR1204', 'MIR1205', 'MIR1206', 'MIR1207', 'MIR1208', 'MTSS1', 'MYC', 'NSMCE2',
                   'PCAT1', 'PGAP3', 'POU5F1B', 'PVT1', 'SQLE', 'TRIB1', 'ZNF536', 'ZNF572')
# subsetgenes_2 <- c('ZWINT', 'CASC8', 'ERBB2', 'FAM84B', 'ZNFN1A3', 'KIAA0196', 'LINC00964', 'MIEN1',
#                    'MIR1204', 'MIR1205', 'MIR1206', 'MIR1207', 'MIR1208', 'MTSS1', 'MYC', 'NSMCE2',
#                    'PCAT1', 'PGAP3', 'POU5F1B', 'PVT1', 'SQLE', 'TRIB1', 'ZNF536', 'ZNF572')
all_ploidies_batch2 = lapply(subsample_samples[grepl("^PDO", names(subsample_samples))],
                             give_ploidy_gene_scaling, subset_genes_arg=subsetgenes_2)
```

```{r, heatmap_ampldel_organoids_v2_b, dependson=c('heatmap_ampldel_organoids_v2'), eval=FALSE}
all_ploidies_batch2b <- do.call('rbind', lapply(1:length(all_ploidies_batch2), function(j) cbind.data.frame(PDO=names(all_ploidies_batch2)[j], gene=names(all_ploidies_batch2[[j]]), CNval=all_ploidies_batch2[[j]]) ))

give_ploidy_gene_scaling(sample = subsample_samples$PDO14, subset_genes_arg = "MIEN1")
all_ploidies_batch2b %>% filter(PDO == 'PDO14', gene == 'MIEN1')

levels_pdo <- c('PDO14', 'PDO5', 'PDO6', 'PDO11', 'PDO9')

ggplot(all_ploidies_batch2b[all_ploidies_batch2b$PDO %in% levels_pdo,], aes(y=CNval, x=gene))+geom_bar(stat = "identity")+coord_flip()+
  facet_wrap(.~factor(PDO, levels=levels_pdo), nrow=1)+geom_hline(yintercept = 2, col='blue')

ggplot(all_ploidies_batch2b, aes(y=log2(CNval), x=gene))+geom_bar(stat = "identity")+coord_flip()+
  facet_wrap(.~(PDO), nrow=1)+geom_hline(yintercept = log2(2), col='blue')+labs('CN (log2)')
  # scale_y_continuous(trans = "log2")
ggsave("../figures/genes_amplified.pdf", width=12) 

ggplot(all_ploidies_batch2b %>% filter(PDO %in% levels_pdo, CNval > 4.4), aes(y=log2(CNval), x=gene))+geom_bar(stat = "identity")+coord_flip()+
  facet_wrap(.~factor(PDO, levels=levels_pdo), nrow=1)+geom_hline(yintercept = 2, col='blue')
ggsave("~/Desktop/genes_CN_log2_gt4.pdf") 

crop <- function(a, thresh){
  a[,'cropped_bool'] = (a[,'CNval'] > thresh)
  a[a[,'CNval'] > thresh,'CNval'] = thresh
  a
}
ggplot(crop(all_ploidies_batch2b[all_ploidies_batch2b$PDO %in% levels_pdo,], 6),  aes(y=CNval, x=gene, col=cropped_bool))+geom_bar(stat = "identity")+coord_flip()+lims(y=c(0,6))+
  facet_wrap(.~factor(PDO, levels=levels_pdo), nrow=1)+geom_hline(yintercept = 2, col='blue')
ggsave("~/Desktop/genes_CN_cropx.pdf")
```


<!-- ## Comparison RNASeq and copy number -->
```{r, correlation_rnaseq_absoluteCN, eval=FALSE}
all_ploidies_2_df_t = t(all_ploidies_2_df)
TPM = read.csv("../RNASeq_DE_resistant_sensitive/files/20191218_ViasM_BJ_orgaBrs_tpm.csv", stringsAsFactors = FALSE)
renaming1 = read_excel("../RNASeq_DE_resistant_sensitive/files/PDOnameProperSample_sWGS_RNAseq.xlsx")

matching_tpm = TPM[match(colnames(all_ploidies_2_df), TPM$gene_name),]
renaming1 = renaming1[match(colnames(matching_tpm), gsub('-', '', renaming1$sampleNameRNAseq)),]
colnames(matching_tpm)[!is.na(renaming1$PDO)] = renaming1$PDO[!is.na(renaming1$PDO)]

length(colnames(matching_tpm))
length( colnames(all_ploidies_2_df_t))
matching_samples = colnames(matching_tpm)[match(colnames(all_ploidies_2_df_t), colnames(matching_tpm))]
matching_samples = matching_samples[!is.na(matching_samples)]
matching_tpm = matching_tpm[,matching_samples]
all_ploidies_2_df_t = all_ploidies_2_df_t[,matching_samples]

dim(all_ploidies_2_df_t)
dim(matching_tpm)

df_correlation_tpm_ploidy = cbind.data.frame(ploidies=as.vector(all_ploidies_2_df_t), tpm=unlist(matching_tpm),
                 gene_name=rep(rownames(all_ploidies_2_df_t), ncol(all_ploidies_2_df_t)),
                 sample_name = rep(colnames(all_ploidies_2_df_t), each=nrow(all_ploidies_2_df_t)))

# ggplot(df_correlation_tpm_ploidy,
#        aes(x=ploidies, y=tpm, col=gene_name))+geom_point()+facet_wrap(.~sample_name)+scale_x_continuous(trans = "log2")

ggthemr::ggthemr_reset()
ggplot(df_correlation_tpm_ploidy,
       aes(x=ploidies, y=tpm#, col=factor(sample_name)
           ))+geom_point()+facet_wrap(.~gene_name, scales = "free")+scale_x_continuous(trans = "log2")+
    labs(x='Absolute CN', y='TPM')

# JBLAB19936 == PDO16
renaming1[which(renaming1$sampleNameRNAseq == "JBLAB-19936"),]
df_correlation_tpm_ploidy[1,]
all_ploidies_2_df['PDO16', 'MYC']
sort(TPM[which(TPM$gene_name == 'MYC'),])

```

```{r, GRanges_deprecated, echo=FALSE}
# library(trackViewer)
# geneInfo[geneInfo$genename == 'TERT',]
# # trackViewer::plotGRanges(all_ranges[[1]], range = as(data.frame(chrom=1, start=1, end=chrlen[1,2]), "GRanges"))
# 
# trackViewer::plotGRanges(all_ranges[[1]], range = as(data.frame(chrom=5, start=748159, end=1548159), "GRanges"))
# 
# trackViewer::plotGRanges(all_ranges[[1]], range = as(data.frame(chrom=5, start=1306282, end=1348159), "GRanges"))
# trackViewer::plotGRanges(all_ranges[[2]], range = as(data.frame(chrom=5, start=1306282, end=1306482), "GRanges"))
# trackViewer::plotGRanges(all_ranges[[1]], range = as(data.frame(chrom=1, start=1, end=30348159), "GRanges"))
# # AneuFinder:::plot.GRanges(all_ranges[[1]])
# # copynumber::plotChrom(segments =  all_ranges[[1]])
# 
# GenomicRanges::intersect(x = all_ranges[[1]], y = as(data.frame(chrom=5, start=748159, end=2048159), "GRanges"))
# GenomicRanges::reduce(c(all_ranges[[1]], as(data.frame(chrom=5, start=748159, end=2048159), "GRanges")))
# # GenomicRanges::disjoin(c(all_ranges[[1]], as(data.frame(chrom=5, start=748159, end=2048159), "GRanges")))
# 
# geneInfo[geneInfo$genename == 'TERT',]
# 
# findOverlaps(query = all_ranges[[1]], subject = as(geneInfo[geneInfo$genename == 'TERT',], "GRanges"))
# all_ranges[[1]][83,]
# 
# give_ploidy_gene(gene_idx = which(gr_genes_of_interest$genename == 'TERT'), sample = all_ranges[[1]])
# sample[83,]

## give_ploidy_gene is correct
## give_ploidy_gene_scaling is not

```


```{r, gene_ploidy_cosmic_plot, echo=FALSE, dependson=c('correlation_rnaseq_absoluteCN'), eval=FALSE}
names(ploidies)
names(ploidies[[1]])
rownames(all_ploidies_2_df_original[match(rownames(ploidies), rownames(all_ploidies_2_df_original)),])[1:10]
rownames(ploidies[1:10,])
all_ploidies_2_df_original = all_ploidies_2_df_original[match(rownames(ploidies), rownames(all_ploidies_2_df_original)),]

sum(na.omit(all_ploidies_2_df_original == 0))
all_ploidies_2_df_original[all_ploidies_2_df_original == 0] = NA

all_ploidies_2_df_cat = sapply(1:nrow(all_ploidies_2_df_original), function(row_idx){
# all_ploidies_2_df_cat = sapply(97, function(row_idx){
  if(ploidies[row_idx,'ploidy'] <= 2.7){
    average_high = FALSE
  }else{
    average_high = TRUE
  }
  # print(average_high)
  sapply(1:ncol(all_ploidies_2_df_original), function(genes_idx){
    # print(all_ploidies_2_df_original[row_idx,genes_idx])
    if(is.na(all_ploidies_2_df_original[row_idx,genes_idx])){
      NA
    }else{
      if( !average_high & (all_ploidies_2_df_original[row_idx,genes_idx] >= 5) ){
        'gain'
      }else if( average_high & (all_ploidies_2_df_original[row_idx,genes_idx] >= 9) ){
        'gain'
      }else if( !average_high & (all_ploidies_2_df_original[row_idx,genes_idx] == 0) ){
        'loss'
      }else if( average_high & ( (all_ploidies_2_df_original[row_idx,genes_idx]) < (ploidies[row_idx,'ploidy']-2.7)  )){
        'loss'
      }else{
        'other'
      }
    }
  })
})

```

```{r, plot_cosmic, echo=FALSE, dependson=c('gene_ploidy_cosmic_plot'), eval=FALSE}
# all_ploidies_2_df_cat
# t(apply((all_ploidies_2_df_cat), 1, function(i) as.numeric(as.factor(i))))
all_ploidies_2_df_cat[all_ploidies_2_df_cat == 'other'] = NA
# all_ploidies_2_df_cat_factors = (apply((all_ploidies_2_df_cat), 1, function(i) as.numeric(as.factor(i))))
# rownames(all_ploidies_2_df_cat_factors) = rownames(all_ploidies_2_df)
all_ploidies_2_df_cat_factors = all_ploidies_2_df_cat
all_ploidies_2_df_cat_factors[all_ploidies_2_df_cat == 'gain'] = 1
all_ploidies_2_df_cat_factors[all_ploidies_2_df_cat == 'loss'] = -1
all_ploidies_2_df_cat_factors[all_ploidies_2_df_cat == 'other'] = NA
all_ploidies_2_df_cat_factors = data.frame(apply(all_ploidies_2_df_cat_factors, 1, as.numeric))
rownames(all_ploidies_2_df_cat_factors) = rownames(all_ploidies_2_df)
colnames(all_ploidies_2_df_cat_factors) = colnames(all_ploidies_2_df)
pheatmap((all_ploidies_2_df_cat_factors),
         annotation_row = ann_row,
         cluster_rows = FALSE, cluster_cols = FALSE, na_col = "white",
show_rownames = FALSE, scale = "none")

all_ploidies_2_df_cat_factors[ann_row == 'Organoids',]

```

Amplifications/deletions of selected genes in organoids
```{r, genes_discrete_organoids_ampdel, echo=FALSE, dependson=c('plot_cosmic', 'gene_ploidy_cosmic_plot'), eval=FALSE}
# subset_all_ploidies_2_df_cat_factors = all_ploidies_2_df_cat_factors[ann_row %in% c('TCGA', 'Organoids'),]
# 
# pheatmap(sapply(subset_all_ploidies_2_df_cat_factors, as.numeric),
#          cluster_rows = FALSE, cluster_cols = FALSE,
#          show_rownames = FALSE, scale = "none")

# image(all_ploidies_2_df_cat_factors[ann_row$cohort %in% c('TCGA'),])
# all_ploidies_2_df_cat_factors[ann_row$cohort %in% c('TCGA'),]
subset_all_ploidies_2_df_cat_factors = all_ploidies_2_df_cat_factors[ann_row$cohort %in% c('Organoids'),]
subset_all_ploidies_2_df_cat_factors[is.na(subset_all_ploidies_2_df_cat_factors)] = 0
subset_all_ploidies_2_df_cat_factors

myColor2 <- colorRampPalette(c("blue", "white", "red"))(3)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd length pallettelengths
# myBreaks2 <- c(seq(-1, 0, length.out=2),
#               seq(0, 1, length.out=1))
myBreaks2 <- c(-2, -0.99, .99, 2)

pheatmap(subset_all_ploidies_2_df_cat_factors,
         cluster_rows = FALSE, cluster_cols = FALSE,
         show_rownames = TRUE, scale = "none",
         color = myColor2, breaks = myBreaks2)
         # color = myColor, breaks = myBreaks)
```

Could you repeat the analysis taking into account the ploidy as recommended by Cosmic?

*  Gain:

§  average genome ploidy <= 2.7 AND total copy number >= 5

§  OR average genome ploidy > 2.7 AND total copy number >= 9

*  Loss:

§  average genome ploidy <= 2.7 AND total copy number = 0

§  OR average genome ploidy > 2.7 AND total copy number < ( average genome ploidy - 2.7 )

Thanks!

Saving the global ploidy for organoids
```{r, saving_global_ploidy, echo=FALSE}
ploidy_organoids
```

How come the segments include all the genome?
```{r, segments_whole_genome}
full_GR_example <- c(GRanges_chroms, as(rename_cols(data.frame(segtables_ICGC_absolute_copynumber_US[[1]])), "GRanges"))
granges_example <- GenomicRanges::disjoin(full_GR_example, with.revmap=TRUE, ignore.strand=TRUE)
diploid_segments = granges_example[sapply(granges_example$revmap, function(i) !any(i > length(GRanges_chroms))),]
diploid_segments
length(diploid_segments)
chrlen
```

```{r}
dim(natgen[[which_natgen]])
```

## Correlations between signatures and features
```{r}

as.vector(number_of_segments$organoids[match(gsub('PDO', '', names(number_of_segments$organoids)), gsub('PDO ', '', rownames(org)))])
# plot(as.vector(number_of_segments$organoids[match(gsub('PDO', '', names(number_of_segments$organoids)), gsub('PDO ', '', rownames(org)))]),
#      org[,'s6'])
# plot(as.vector(number_of_segments$organoids[match(gsub('PDO', '', names(number_of_segments$organoids)), gsub('PDO ', '', rownames(org)))]),
#      org[,'s6']/org[,'s1'])
```

## Ascites
```{r, ascites_barplot}
ascites = read.csv("data/asorg_PDO.csv")
ascites = cbind(ascites, bool_ascites=c('Ascites','Organoid'))
ascites = cbind(ascites, sample_paired=rep(1:(nrow(ascites)/2), each=2))
ascites$sample = factor(ascites$sample, levels = ascites$sample)
ggplot(melt(ascites, id.vars=c('sample', 'bool_ascites', 'sample_paired')), aes(x=sample, y=value, fill=variable))+geom_bar(stat = "identity")+facet_wrap(.~bool_ascites, scales = "free_x", ncol=2)+
  scale_fill_brewer(palette="Dark2")
ggsave("figures/barplot_ascites_organoids.pdf", width = 7.5, height = 5)
saveRDS(ascites, "robjects/fig4_ascites.RDS")
```


```{r, ternary_plots}
all_natgen[[which_natgen]][ grepl("^PDO*", rownames(all_natgen[[which_natgen]])) ,]


library(Ternary)

amalgamation = cbind(rowSums(all_natgen[[which_natgen]][,-c(1,3)]),
      all_natgen[[which_natgen]][,1],
      all_natgen[[which_natgen]][,3])
colnames(amalgamation) = c('Rest', 's1', 's3')
amalgamation1 = amalgamation[grepl("^PDO*", rownames(all_natgen[[which_natgen]])),]
amalgamation2 = amalgamation[!grepl("^PDO*", rownames(all_natgen[[which_natgen]])),]

head(amalgamation1)
head(amalgamation2)

nPoints <- 4000L
coordinates <- cbind(abs(rnorm(nPoints, 2, 3)),
                     abs(rnorm(nPoints, 1, 1.5)),
                     abs(rnorm(nPoints, 1, 0.5)))

TernaryPlot(atip = colnames(amalgamation)[1], btip = colnames(amalgamation)[2], ctip = colnames(amalgamation)[3],
            main='Organoids')
ColourTernary(TernaryDensity(amalgamation1, resolution = 10L))
TernaryPoints(amalgamation1, col = 'red', pch = '.')
TernaryDensityContour(amalgamation1, resolution = 30L)

TernaryPlot(atip = colnames(amalgamation)[1], btip = colnames(amalgamation)[2], ctip = colnames(amalgamation)[3],
            main='Primary cohorts')
ColourTernary(TernaryDensity(amalgamation2, resolution = 10L))
TernaryPoints(amalgamation2, col = 'red', pch = '.')
TernaryDensityContour(amalgamation2, resolution = 30L)

```

```{r, quiet_organoids}
(number_of_segments$organoids)
```

```{r, ascites_matching, eval=FALSE}
all((organoids_absolute_copynumber@assayData$copynumber) == organoids_absolute_copynumber2@assayData$copynumber, na.rm = T)

require(reshape2)
require(ggplot2)
exposures = readRDS("data/ascites_exposures_20210125.rds")
exposures
ggplot(melt(cbind(org=rownames(exposures), exposures)), aes(x=org, y=value, fill=variable))+geom_bar(stat='identity')

org == exposures

book_ascites = readxl::read_xlsx("data/Book1.xlsx")

exposures = exposures[match(book_ascites$`JBLAB-number`, rownames(exposures)),]
exposures = exposures[!colSums(apply(exposures, 1, is.na)) == 7,]
rownames(exposures) = book_ascites$organoid[match(book_ascites$`JBLAB-number`, rownames(exposures))]

## Data from organoids

rename_rows = function(i, new_names){
  rownames(i) = new_names; return(i)}


createBarplot(rename_rows(exposures, gsub('Sample ', 'PDO', rownames(exposures))), remove_labels = FALSE, order_labels = gsub('Sample ', 'PDO', names(sort(exposures[,1])))) + 
  scale_fill_brewer(palette="Dark2")+labs(y='Exposure')+
  ggtitle('Exposures for the organoids')+labs(x='')+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

gsub('org', '', rownames(exposures))
matched_ascites = ascites[match(gsub('org', '', rownames(exposures)), (ascites$sample)),2:ncol(ascites)]
all.equal(matched_ascites, exposures)
matched_ascites[1,] == exposures[1,]
matched_ascites[1,]
exposures[1,]

```

<!-- ### Copy number status of regions of the genome which seem to be subclonal according to scDNA -->
```{r, cn_regions_subclonal, echo=FALSE, eval=F}

give_plot_areas_of_interest = function(segtab, chrom_AOI, start_AOI, end_AOI, subclonal_line1, subclonal_line2, title){
  region_subclonal = as(cbind.data.frame(chromosome=chrom_AOI, start=start_AOI,
                                             end=end_AOI),
                               "GRanges")
  region_subclonal
  as(data.frame(segtab),"GRanges")
  
  disjoin_region_subclonal <- GenomicRanges::disjoin(c(
    region_subclonal,
    as(data.frame(segtab),"GRanges")),
    with.revmap=TRUE, ignore.strand=TRUE)
  
  disjoin_region_subclonal = disjoin_region_subclonal[sapply(disjoin_region_subclonal$revmap, function(i) 1 %in% i),]
  
  CN = sapply(disjoin_region_subclonal$revmap, function(i){
    if(!is.na(i[2])){
      as(data.frame(segtab),"GRanges")$segVal[i[2]-length(region_subclonal)]
    }else{
      2
    }
  })
  
  disjoin_region_subclonal$CNval = CN
  
  return(list(disjoin_region_subclonal,
    ggplot(cbind.data.frame(start=start(disjoin_region_subclonal),
     end=end(disjoin_region_subclonal),
     CNval=disjoin_region_subclonal$CNval))+
    # geom_segment(aes(x=start, xend=end, y=CNval, yend=CNval))+
    geom_rect(aes(xmin=start, xmax=end, ymin=0, ymax=CNval), alpha=0.2)+
    geom_abline(slope = 0, intercept = subclonal_line1, color='blue', lty='dashed')+
    geom_abline(slope = 0, intercept = subclonal_line2, color='blue', lty='dashed')+
    ggtitle(title)))
}

```

```{r, cn_regions_subclonal_individual, echo=FALSE, eval=FALSE}
give_plot_areas_of_interest_individual = function(segtab, chrom_AOI, start_AOI, end_AOI, subclonal_line1, subclonal_line2, title){
  region_subclonal = as(cbind.data.frame(chromosome=chrom_AOI, start=start_AOI,
                                             end=end_AOI),
                               "GRanges")
  disjoin_region_subclonal <- GenomicRanges::disjoin(c(
    region_subclonal,
    as(data.frame(segtab),"GRanges")),
    with.revmap=TRUE, ignore.strand=TRUE)
  
  disjoin_region_subclonal = disjoin_region_subclonal[sapply(disjoin_region_subclonal$revmap, function(i) 1 %in% i),]
  
  CN = sapply(disjoin_region_subclonal$revmap, function(i){
    if(!is.na(i[2])){
      as(data.frame(segtab),"GRanges")$segVal[i[2]]
    }else{
      2
    }
  })
  
  disjoin_region_subclonal$CNval = CN
  
  return(disjoin_region_subclonal)
}

```
- PDO2
  - Check in sWGS of bulk cells whether chrom 7 has an amplification at ~2.5
  - Same for first quarter of chrom 10
  - Same for last 3/4 of chrom 10
- PDO3
  - Chromosome 5
- PDO6  
    - Chromosome 4, small region of extreme amplification
```{r, cn_regions_subclonal2, echo=FALSE, dependson=c('cn_regions_subclonal', 'cn_regions_subclonal_individual'), eval=FALSE}

plts_AOI_subclonal = list(give_plot_areas_of_interest(segtab=segtables_organoids_absolute_copynumber$PDO2,
                            chrom_AOI=7, start_AOI=1,
                            end_AOI=chrlen %>% filter(V1 == "chr7") %>% dplyr::select(V2) %>% as.integer(),
                            subclonal_line1=2, subclonal_line2=3, title='Chrom 7 in PDO2'),
                          give_plot_areas_of_interest(segtab=segtables_organoids_absolute_copynumber$PDO2,
                            chrom_AOI=10, start_AOI=1,
                            end_AOI=135534747/4,
                            subclonal_line1=2, subclonal_line2=3, title='Chrom 10 (start) in PDO2'),
                          give_plot_areas_of_interest(segtab=segtables_organoids_absolute_copynumber$PDO2,
                            chrom_AOI=10,
                            start_AOI=chrlen %>% filter(V1 == "chr10") %>% dplyr::select(V2) %>% as.integer() / 4,
                            end_AOI=chrlen %>% filter(V1 == "chr10") %>% dplyr::select(V2) %>% as.integer(),
                            subclonal_line1=2, subclonal_line2=3, title='Chrom 10 (start) in PDO2'),
                          give_plot_areas_of_interest(segtab=segtables_organoids_absolute_copynumber$PDO3,
                            chrom_AOI=5,
                            start_AOI=51200001,
                            end_AOI=66560000,
                            subclonal_line1=2, subclonal_line2=1, title='Chrom 5 (start) in PDO3'),
                          give_plot_areas_of_interest(segtab=segtables_organoids_absolute_copynumber$PDO3,
                            chrom_AOI=5,
                            start_AOI=chrlen %>% filter(V1 == "chr5") %>% dplyr::select(V2) %>% as.integer() * 2/3,
                            end_AOI=chrlen %>% filter(V1 == "chr5") %>% dplyr::select(V2) %>% as.integer(),
                            subclonal_line1=2, subclonal_line2=3, title='Chrom 5 (end) in PDO3'),
                          give_plot_areas_of_interest(segtab=segtables_organoids_absolute_copynumber$PDO6,
                            chrom_AOI=4,
                            start_AOI=71680001,
                            end_AOI=81920000,
                            subclonal_line1=2, subclonal_line2=3, title='Chrom 4 (end) in PDO6'))
```

```{r, cn_regions_subclonal3, dependson=c('cn_regions_subclonal2'), echo=FALSE, eval=FALSE}
do.call('grid.arrange', c(sapply(plts_AOI_subclonal, `[`, 2), list(nrow=2)))
```

```{r, cn_regions_subclonal4, dependson=c('cn_regions_subclonal2'), eval=FALSE}
sapply(plts_AOI_subclonal, `[`, 1)
```
