upper_half = df[df[,idx_frac] > means[idx_frac],idx_frac]
.x = (cut(lower_half, breaks = quantile(lower_half), include.lowest = TRUE))
.x2 = (cut(upper_half, breaks = quantile(upper_half), include.lowest = TRUE))
cuts = c(as.numeric(.x), as.numeric(.x2)+4)
a = df[,idx_frac][sapply(unique(cuts), function(i) which(cuts == i)[sum(cuts == i)])]
a - c(0,a[-length(a)])
return(cbind.data.frame(frac=a - c(0,a[-length(a)]), nm=c(1:4, 4:1), fracid=rep(idx_frac,8)))
})
for(i in 2:ncol(df)){
res[[i]][,'frac'] = res[[i]][,'frac'] + res[[i-1]][nrow(res[[i-1]]['frac']),'frac'] #- res[[i]][1,'frac']
}
ggthemr::ggthemr('dust')
ggplot(do.call('rbind', res), aes(x=1, fill=factor(fracid), y=frac))+
geom_bar(aes(alpha=log(log(nm))), stat = "identity")
}
plot_uncertain_compositional_data(x)
plot_uncertain_compositional_data(MCMCpack::rdirichlet(100, rep(6,4)))
rm(list(ls()))
x <- MCMCpack::rdirichlet(100, rep(1,4))
#' df is a dataframe in which each column represents a part in the composition and each row represents an instance
plot_uncertain_compositional_data <- function(df){
require(ggplot2)
## we are going to compute 5 quantiles (centered around the mean, or mauybe geometric mean) for each of the parts
means <- colMeans(df)
warning('This is symmetrical around the mean, but maube what we would want is that a single quantile is centered around the mean')
df <- apply(df, 2, sort)
res = lapply(1:ncol(df), function(idx_frac){
lower_half = df[df[,idx_frac] <= means[idx_frac],idx_frac]
upper_half = df[df[,idx_frac] > means[idx_frac],idx_frac]
.x = (cut(lower_half, breaks = quantile(lower_half), include.lowest = TRUE))
.x2 = (cut(upper_half, breaks = quantile(upper_half), include.lowest = TRUE))
cuts = c(as.numeric(.x), as.numeric(.x2)+4)
a = df[,idx_frac][sapply(unique(cuts), function(i) which(cuts == i)[sum(cuts == i)])]
a - c(0,a[-length(a)])
return(cbind.data.frame(frac=a - c(0,a[-length(a)]), nm=c(1:4, 4:1), fracid=rep(idx_frac,8)))
})
for(i in 2:ncol(df)){
res[[i]][,'frac'] = res[[i]][,'frac'] + res[[i-1]][nrow(res[[i-1]]['frac']),'frac'] #- res[[i]][1,'frac']
}
ggplot(do.call('rbind', res), aes(x=1, fill=factor(fracid), y=frac))+
geom_bar(aes(alpha=log(log(nm))), stat = "identity")
}
plot_uncertain_compositional_data(x)
plot_uncertain_compositional_data(MCMCpack::rdirichlet(100, rep(6,4)))
MCMCpack::rdirichlet(100, rep(6,4)
)
plot_uncertain_compositional_data(MCMCpack::rdirichlet(100, c(5,1,3,10)))
plot_uncertain_compositional_data(MCMCpack::rdirichlet(100, c(50,1,3,10)))
tree = "((B,C),A);"
ape::read.tree(text = tree)
plot(ape::read.tree(text = tree))
tree_naked = gsub(";", "", tree)
tree_naked
tree = "((B1,B2),(A1,A2);"
plot(ape::read.tree(text = tree)) ## valid tree
tree_naked = gsub(";", "", tree)
tree = "((B1,B2),(A1,A2);"
tree = "((B1,B2),(A1,A2));"
plot(ape::read.tree(text = tree)) ## valid tree
tree_naked = gsub(";", "", tree)
tree_naked
nleaves = strsplit(tree, split = "(|)")
nleaves
tree = gsub(";", "", tree)
nleaves = strsplit(tree, split = "(|)")[[1]]
nleaves
nleaves = strsplit(tree, split = "\\(|\\)")[[1]]
nleaves
nleaves = strsplit(tree, split = "\\(|\\,\\,)")[[1]]
nleaves
nleaves = strsplit(tree, split = "\\(|\\)|\\,)")[[1]]
nleaves
nleaves = strsplit(tree, split = "\\(|\\)|\,)")[[1]]
nleaves = strsplit(tree, split = "\\(|\\)|,)")[[1]]
nleaves
nleaves = strsplit(tree, split = "\\(|\\)|\\,)")[[1]]
nleaves
nleaves = strsplit(tree, split = "\\(|\\)|\\,")[[1]]
nleaves
give_nleaves = function(tree){
.x strsplit(tree, split = "\\(|\\)|\\,")[[1]]
.x[.x != ""]
}
give_nleaves = function(tree){
.x = strsplit(tree, split = "\\(|\\)|\\,")[[1]]
.x[.x != ""]
}
nleaves = give_nleaves(tree)
nleaves
give_leaves = function(tree){
.x = strsplit(tree, split = "\\(|\\)|\\,")[[1]]
.x[.x != ""]
}
give_leaves = function(tree){
length(give_leaves(tree))
}
nleaves = give_nleaves(tree)
nleaves
give_leaves = function(tree){
.x = strsplit(tree, split = "\\(|\\)|\\,")[[1]]
.x[.x != ""]
}
give_nleaves = function(tree){
length(give_leaves(tree))
}
tree = gsub(";", "", tree)
nleaves = give_nleaves(tree)
nleaves
tree
## remove parenthesis
.tree = substr(tree, 2, nchar(tree)-1)
.tree
split_tree = function(tree){
strsplit(tree, split = "\\(|\\)|\\,")[[1]]
}
give_leaves = function(tree){
.x = split_tree(tree)
.x[.x != ""]
}
give_nleaves = function(tree){
length(give_leaves(tree))
}
get_next_split = function(tree){
## remove parenthesis
.tree = substr(tree, 2, nchar(tree)-1)
which(.tree)
}
tree = gsub(";", "", tree)
nleaves = give_nleaves(tree)
nleaves
## remove parenthesis
.tree = substr(tree, 2, nchar(tree)-1)
split_tree(.tree)
split_tree(.tree)
(.tree)
split(.tree, "")
split_tree = function(tree, drop = TRUE){
strsplit(tree, split = "\\(|\\)|\\,", , drop = drop)[[1]]
}
split_tree(.tree, "", drop = FALSE)
split_tree(.tree,  drop = FALSE)
split_tree = function(tree, drop = TRUE){
strsplit(tree, split = "\\(|\\)|\\,", , drop = drop)[[1]]
}
split_tree(.tree,  drop = FALSE)
split_tree = function(tree, drop = TRUE){
strsplit(tree, split = "\\(|\\)|\\,", drop = drop)[[1]]
}
split_tree(.tree,  drop = FALSE)
split_tree = function(tree, ...){
strsplit(tree, split = "\\(|\\)|\\,", ....)[[1]]
}
split_tree(.tree,  drop = FALSE)
split_tree = function(tree, ...){
strsplit(tree, split = "\\(|\\)|\\,", ...)[[1]]
}
split_tree(.tree,  drop = FALSE)
strsplit(.tree, "(?=[/&])", perl = TRUE)
strsplit(.tree, "(?=[/,])", perl = TRUE)[[1]]
strsplit(.tree, "(?=[/,|/(])", perl = TRUE)[[1]]
strsplit(.tree, "(?=[/,|/(|/(])", perl = TRUE)[[1]]
strsplit(.tree, "(?=[/,|/(|/)])", perl = TRUE)[[1]]
split_tree = function(tree, keep=FALSE){
if(keep){
strsplit(tree, "(?=[/,|/(|/)])", perl = TRUE)[[1]]
}else{
strsplit(tree, split = "\\(|\\)|\\,", ...)[[1]]
}
}
split_tree(.tree,  keep = TRUE)
.tree = split_tree(.tree,  keep = TRUE)
## move forward. if first we find an opening parenthesis, keep it until it closes. if first we get a comma, split.
which(.tree = "(")
## move forward. if first we find an opening parenthesis, keep it until it closes. if first we get a comma, split.
which(.tree == "(")
which(.tree == ",")
## move forward. if first we find an opening parenthesis, keep it until it closes. if first we get a comma, split.
min(which(.tree == "("))
min(which(.tree == ","))
.tree
nparsleft = 0; nparsright = 0
## .tree is a vector with split characters
dontstop = TRUE; nparsleft = 0; nparsright = 0
while(dontstop){
if(.tree == "("){
nparsleft = nparsleft + 1
}
if(.tree == "("){
nparsright = nparsright +1
}
if(nparsleft == nparsright) break
}
## .tree is a vector with split characters
dontstop = TRUE; idx=1; nparsleft = 0; nparsright = 0
while(dontstop){
if(.tree[idx] == "("){
nparsleft = nparsleft + 1
}
if(.tree[idx] == "("){
nparsright = nparsright +1
}
if(nparsleft == nparsright) break
idx = idx + 1
}
idx
nparsleft
## .tree is a vector with split characters
dontstop = TRUE; idx=1; nparsleft = 0; nparsright = 0
while(dontstop){
if(.tree[idx] == "("){
nparsleft = nparsleft + 1
}
if(.tree[idx] == ")"){
nparsright = nparsright +1
}
if(nparsleft == nparsright) break
idx = idx + 1
}
idx
.tree
.tree[1:idx]
list(.tree[1:idx], .tree[(idx+1):length(.tree)]
}
find_split = function(.tree){
## move forward. if first we find an opening parenthesis, keep it until it closes. if first we get a comma, split.
if(min(which(.tree == "(")) < min(which(.tree == ","))){
prnths = TRUE
}else{
prnths = FALSE
}
if(prnths){
which_close = find_close_parenthesis(.tree)
}
}
give_leaves = function(tree){
.x = split_tree(tree)
.x[.x != ""]
}
give_nleaves = function(tree){
length(give_leaves(tree))
}
get_next_split = function(tree){
## remove parenthesis
.tree = substr(tree, 2, nchar(tree)-1)
.tree = split_tree(.tree,  keep = TRUE)
}
tree = gsub(";", "", tree)
nleaves = give_nleaves(tree)
nleaves
if(nleaves > 1){
## split tree into two
get_next_split(tree)
}else{
## do not remove parenthesis; do not split
}
list(.tree[1:idx], .tree[(idx+1):length(.tree)])
list(.tree[1:idx], .tree[(idx+2):length(.tree)])
find_close_parenthesis = function(.tree){
## .tree is a vector with split characters
dontstop = TRUE; idx=1; nparsleft = 0; nparsright = 0
while(dontstop){
if(.tree[idx] == "("){
nparsleft = nparsleft + 1
}
if(.tree[idx] == ")"){
nparsright = nparsright +1
}
if(nparsleft == nparsright) break
idx = idx + 1
}
return(list(.tree[1:idx], .tree[(idx+2):length(.tree)]))
}
which_close = find_close_parenthesis(.tree)
which_close
find_close_parenthesis = function(.tree){
## .tree is a vector with split characters
dontstop = TRUE; idx=1; nparsleft = 0; nparsright = 0
while(dontstop){
if(.tree[idx] == "("){
nparsleft = nparsleft + 1
}
if(.tree[idx] == ")"){
nparsright = nparsright +1
}
if(nparsleft == nparsright) break
idx = idx + 1
}
return(list(paste0(.tree[1:idx], collapse = ""), paste0(.tree[(idx+2):length(.tree)], collapse = "")))
}
rm(find_close_parenthesis)
give_split = function(.tree){
## .tree is a vector with split characters
dontstop = TRUE; idx=1; nparsleft = 0; nparsright = 0
while(dontstop){
if(.tree[idx] == "("){
nparsleft = nparsleft + 1
}
if(.tree[idx] == ")"){
nparsright = nparsright +1
}
if(nparsleft == nparsright) break
idx = idx + 1
}
return(list(paste0(.tree[1:idx], collapse = ""), paste0(.tree[(idx+2):length(.tree)], collapse = "")))
}
which_close = give_split(.tree)
which_close
splts = give_split(.tree)
splts
find_split(splts[[1]])
find_split(splts[[2]])
x <- -6:16
op <- par(mfrow = c(2, 2))
contour(outer(x, x), method = "edge", vfont = c("sans serif", "plain"))
z <- outer(x, sqrt(abs(x)), FUN = "/")
## Should not be necessary:
z[!is.finite(z)] <- NA
image(x, x, z)
contour(x, x, z, col = "pink", add = TRUE, method = "edge",
vfont = c("sans serif", "plain"))
contour(x, x, z, ylim = c(1, 6), method = "simple", labcex = 1)
contour(x, x, z, ylim = c(-6, 6), nlev = 20, lty = 2, method = "simple")
contour(x, x, z, ylim = c(-6, 6), nlev = 20, lty = 2, method = "simple", col='blue')
length(x)
rnorm(23)
contour(rnorm(23), rnorm(23), z, col = "pink", add = TRUE, method = "edge",
vfont = c("sans serif", "plain"))
contour(sort(rnorm(23)), rnorm(23), z, col = "pink", add = TRUE, method = "edge",
vfont = c("sans serif", "plain"))
contour(sort(rnorm(23)), sort(rnorm(23)), z, col = "pink", add = TRUE, method = "edge",
vfont = c("sans serif", "plain"))
dev.off()
contour(sort(rnorm(23)), sort(rnorm(23)), z, col = "pink", add = TRUE, method = "edge",
vfont = c("sans serif", "plain"))
image(x, x, z)
contour(sort(rnorm(23)), sort(rnorm(23)), z, col = "pink", add = TRUE, method = "edge",
vfont = c("sans serif", "plain"))
suppressMessages(library(optparse))
suppressMessages(library(rnaseqRpkg))
source("other_scripts/utilities.R")
parseCommandLine <- function() {
parser <- OptionParser(description="Perform a differential binding analysis using DESeq2")
parser <- add_option(parser,"--sampleSheet",
help="sample sheet")
parser <- add_option(parser,"--model",
help="model for DE analysis (in text form)")
parser <- add_option(parser,"--counts_raw",
help="table of raw counts")
parser <- add_option(parser,"--deaObjectFile",
help="file to write DEA object to")
opts = parse_args(parser,positional_arguments=0)
return(opts$options)
}
loadCountTable <- function(fn) {
data <- read.csv(fn,row.names=1,header=TRUE,check.names=FALSE)
return(data)
}
loadRefFlat <- function(fn) {
data <- read.table(fn,sep="\t",quote="",header=FALSE,
colClasses=c("character","NULL","character","character",
"numeric","numeric","NULL","NULL","NULL",
"NULL","NULL"))
colnames(data) <- c('Gene','Chrom','Strand','Left','Right')
return(data)
}
loadGeneNames <- function(fn) {
data <- read.table(fn,sep="\t",quote="",header=FALSE)
colnames(data) <- c('Gene','Symbol','Name')
return(data)
}
annotateGenes <- function(mat,refflat,geneNames) {
refflat_ordered <- refflat[match(rownames(mat),refflat$Gene),]
geneNames_ordered <- geneNames[match(rownames(mat),geneNames$Gene),]
mat$chrom <- refflat_ordered$Chrom
mat$strand <- refflat_ordered$Strand
mat$left <- refflat_ordered$Left
mat$right <- refflat_ordered$Right
mat$symbol <- geneNames_ordered$Symbol
mat$name <- geneNames_ordered$Name
return(mat)
}
makeVolcanoPlot <- function(results,target_dir,prefix) {
fn <- file.path(target_dir,sprintf("%s_VolcanoPlot.pdf",prefix))
pdf(fn)
print(plotVolcanogg(results))
dev.off()
}
makeMAplot <- function(results,target_dir,prefix) {
fn <- file.path(target_dir,sprintf("%s_MAplot.pdf",prefix))
pdf(fn)
print(plotMAgg(results))
dev.off()
}
makeHeatmap <- function(deMat,report,count,target_dir,prefix,all_samples,target,num,denom) {
if (all_samples) {
label <- "allSamples"
} else {
label <- "testSamples"
wanted <- colData(deMat)[,target] %in% c(num,denom)
deMat <- deMat[,wanted]
}
fn <- file.path(target_dir,sprintf("%s_top200_heatmap_%s.pdf",
prefix,label))
pdf(fn)
print(plotTopNSigHeatmap(report,deMat,target,topN=count))
dev.off()
}
makePCA <- function(deMat,model,report,target_dir,prefix,target,numerator,denominator,samples) {
fn <- file.path(target_dir,sprintf("%s_PCA.pdf",prefix))
pdf(fn)
print(plotPCAbyContrast(report,target,deMat,samples))
dev.off()
}
getMean <- function(data,factor,values,sample) {
cols <- sample[,factor] %in% values
data <- data[,cols,drop=FALSE]
sums <- apply(data,c(1),sum)
return(sums/sum(cols))
}
getMeans <- function(mat,factor,numerator,denominator,samples) {
data <- counts(mat,normalized=TRUE)
numData <- getMean(data,factor,numerator,samples)
denData <- getMean(data,factor,denominator,samples)
allData <- getMean(data,factor,c(numerator,denominator),samples)
df <- data.frame(allData,numData,denData)
colnames(df) <- c("Both_Mean",sprintf("%s_Mean",numerator),sprintf("%s_Mean",denominator))
return(df)
}
addMeans <- function(mat,res,factor,numerator,denominator,samples) {
means <- getMeans(mat,factor,numerator,denominator,samples)
means$FC = 2^res$log2FoldChange
res <- cbind(res,means)
res <- res[c(1,7,8,9,2,10,3,4,5,6)]
return(res)
}
writeReport <- function(deMat,model,target,denominator,numerator,refflat,geneNames,destDir,subDir,fnPrefix,samples) {
target_dir <- file.path(destDir,subDir)
fnBase <- sprintf("%s_DEA_%s-vs-%s",fnPrefix,numerator,denominator)
if (!dir.exists(target_dir)) {
dir.create(target_dir)
}
report <- results(deMat,c(target,numerator,denominator),alpha=0.05,format='DataFrame')
report_df <- as.data.frame(addMeans(deMat,report,target,numerator,denominator,samples))
for (column in (1:6)) {
report_df[,column] <- round(report_df[,column],3)
}
report_df <- annotateGenes(report_df,refflat,geneNames)
report_df$location <- with(report_df,paste(chrom,":",left,"-",right,sep=""))
fn_all <- file.path(destDir,subDir,sprintf("%s_all.csv",fnBase))
write.csv(report_df,file=fn_all)
fn_filt <- file.path(destDir,subDir,sprintf("%s_filtered.csv",fnBase))
report_filt <- report_df[!is.na(report_df$padj)&report_df$padj<0.05,]
write.csv(report_filt,file=fn_filt)
makeMAplot(report,target_dir,fnBase)
makeVolcanoPlot(report,target_dir,fnBase)
if (nrow(report_filt) > 0) {
makeHeatmap(deMat,report_filt,200,target_dir,fnBase,all_samples=TRUE,target,numerator,denominator)
makeHeatmap(deMat,report_filt,200,target_dir,fnBase,all_samples=FALSE,target,numerator,denominator)
makePCA(deMat,model,report,target_dir,fnBase,target,numerator,denominator,samples)
}
numeratorCount <- sum(samples[[target]] == numerator)
denominatorCount <- sum(samples[[target]] == denominator)
upcount <- sum(report_filt$log2FoldChange > 0)
downcount <- sum(report_filt$log2FoldChange < 0)
return(c(upcount,downcount,numeratorCount,denominatorCount))
}
runDEanalysis <- function(model,samples,counts,refflat,geneNames,outputDir) {
#  print(sprintf("outputDir: %s",outputDir))
fsamples <- sampleSheet2Factors(samples)
print(fsamples)
head(counts)
print(model)
mat <- suppressMessages(DESeqDataSetFromMatrix(countData=counts,colData=fsamples,design=model))
mat <- estimateSizeFactors(mat)
mat <- suppressMessages(estimateDispersions(mat,fitType="local"))
tryCatch( mat <- nbinomWaldTest(mat),
error = function(e) {message("failed in nbinom")})
terms <- rev(labels(terms(model)))
fnPrefix <- paste(terms,sep="-",collapse="-")
target <- terms[1]
values <- levels(fsamples[,target])
nval <- length(values)
summaries <- list()
for (i in 1:(nval-1)) {
for (j in (i+1):nval) {
subdir <- sprintf("%s_DEA_%s_vs_%s",fnPrefix,values[j],values[i])
#      print(fnPrefix)
#      print(values[j])
#      print(values[i])
#      print(sprintf("subDir: %s",subdir))
upAndDown <- writeReport(mat,model,target,values[i],values[j],refflat,geneNames,outputDir,subdir,fnPrefix,samples)
res <- c('Model'=as.character(model),'Numerator'=values[j],'Denominator'=values[i],'Up-regulated'=upAndDown[1],'Down-regulated'=upAndDown[2],'NumCount'=upAndDown[3],'DenomCount'=upAndDown[4])
summaries <- c(summaries,list(res))
}
}
return(list(mat,summaries))
}
setwd("/Users/morril01/Documents/PhD/other_repos/b_tape/Vias_Brenton/DE_resistant_sensitive/analysis_scripts")
opts = list()
opts$sampleSheet = "files/sample_sheet.csv"
opts$model <- "~response"
opts$counts_raw <- "files/table_raw_counts.csv"
opts$deaObjectFile <- "../objects/deaObjectFile"
samplesFN <- opts$sampleSheet
modelStr <- opts$model
# countsFN <- as.matrix(read.table(opts$counts_raw, sep = "\t", row.names = 1, header = TRUE))
countsFN <- opts$counts_raw
destination <- opts$deaObjectFile
deaObj <- runDEAnalysis(sampleSheetFN = samplesFN, modelString = modelStr, countsFN=countsFN)
sampleSheetFN = samplesFN
deaObj
destination
